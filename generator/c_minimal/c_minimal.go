package c_minimal

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/xaxys/bubbler/definition"
	"github.com/xaxys/bubbler/util"
)

var fileHeader = `// Target: C-Minimal
// Generated by bubbler
// DO NOT EDIT
#include <stdint.h>
#include <stdbool.h>

`

var typeMap = map[definition.TypeID]string{
	definition.TypeID_Bool:    "bool",
	definition.TypeID_Uint8:   "uint8_t",
	definition.TypeID_Uint16:  "uint16_t",
	definition.TypeID_Uint32:  "uint32_t",
	definition.TypeID_Uint64:  "uint64_t",
	definition.TypeID_Int8:    "int8_t",
	definition.TypeID_Int16:   "int16_t",
	definition.TypeID_Int32:   "int32_t",
	definition.TypeID_Int64:   "int64_t",
	definition.TypeID_Float32: "float",
	definition.TypeID_Float64: "double",
	definition.TypeID_String:  "char*",
	definition.TypeID_Bytes:   "uint8_t*",
}

type CMinimalGenerator struct {
	Generated map[string]bool
}

func NewCMinimalGenerator() *CMinimalGenerator {
	return &CMinimalGenerator{}
}

func (g *CMinimalGenerator) Generate(unit *definition.CompilationUnit) (string, error) {
	g.Generated = make(map[string]bool)
	str := fileHeader
	for _, type_ := range unit.Types.Values() {
		topDef, methods := g.generateType(type_)
		str += fmt.Sprintf("%s;\n\n%s", topDef, methods)
	}
	return str, nil
}

func (g *CMinimalGenerator) generateType(type_ definition.Type) (def string, method string) {
	switch val := type_.(type) {
	case *definition.Struct:
		if g.Generated[val.StructName] == true {
			return fmt.Sprintf("struct %s", val.StructName), ""
		}
		g.Generated[val.StructName] = true
		return g.generateStruct(val)

	case *definition.Enum:
		if g.Generated[val.EnumName] == true {
			return fmt.Sprintf("enum %s", val.EnumName), ""
		}
		g.Generated[val.EnumName] = true
		return g.generateEnum(val), ""

	case *definition.BasicType:
		return typeMap[val.TypeTypeID], ""

	case *definition.Array:
		panic("unreachable")

	case *definition.String:
		panic("unimplemented")

	case *definition.Bytes:
		panic("unimplemented")

	default:
		panic("unreachable")
	}
}

func (g *CMinimalGenerator) generateStruct(structDef *definition.Struct) (def string, method string) {
	methodsStr := ""
	fieldsStr := ""
	startBits := int64(0)
	for _, field := range structDef.StructFields {
		from := startBits
		to := startBits + field.GetFieldBitSize()
		pos := fmt.Sprintf("[%s, %s)", util.ToSizeString(from), util.ToSizeString(to))
		if from == to {
			pos = "[virtual]"
		}
		startBits += field.GetFieldBitSize()

		switch val := field.(type) {
		case *definition.ConstantField:
			fieldStr := fmt.Sprintf("// %s ConstantField: %s\n", pos, val.ShortString())
			if val.FieldName != "" {
				tyStr, _ := g.generateType(val.FieldType)
				fieldStr += fmt.Sprintf("const %s %s;\n", tyStr, val.FieldName)
			}
			fieldsStr += util.IndentSpace4(fieldStr)

		case *definition.VoidField:
			fieldStr := fmt.Sprintf("// %s VoidField: %s\n", pos, val.ShortString())
			fieldsStr += util.IndentSpace4(fieldStr)

		case *definition.EmbeddedField:
			fieldStr := fmt.Sprintf("// %s EmbeddedField: %s\n", pos, val.ShortString())
			fieldsStr += util.IndentSpace4(fieldStr)

		case *definition.NormalField:
			fieldStr := fmt.Sprintf("// %s NormalField: %s\n", pos, val.ShortString())
			if arrayTy, ok := val.FieldType.(*definition.Array); ok {
				tyStr, _ := g.generateType(arrayTy.ElementType)
				fieldStr += fmt.Sprintf("%s %s[%d];\n", tyStr, val.FieldName, arrayTy.Length)
			} else {
				tyStr, methods := g.generateType(val.FieldType)
				fieldStr += fmt.Sprintf("%s %s;\n", tyStr, val.FieldName)
				methodsStr += methods
				methodsStr += g.generateMethods(structDef, val)
			}
			fieldsStr += util.IndentSpace4(fieldStr)

		default:
			panic("unreachable")
		}
	}
	methodsStr += fmt.Sprintf("static const unsigned long long %s_Size = %d;\n", structDef.StructName, structDef.StructBitSize/8)
	methodsStr += g.generateEncoder(structDef) + "\n"
	methodsStr += g.generateDecoder(structDef) + "\n"
	defStr := fmt.Sprintf("// Struct: %s\nstruct %s {\n%s}", structDef.ShortString(), structDef.StructName, fieldsStr)
	return defStr, methodsStr
}

func (g *CMinimalGenerator) generateEncoder(structDef *definition.Struct) string {
	genEncode := func(from, to int64, fieldData func(int64) string) string {
		encodeStr := ""
		for i := from; i < to; i = (i + 8) & (^7) {
			nextI := min(to, (i+8)&(^7))
			dataMask := ((1 << (((nextI - 1) & 7) + 1)) - 1) & (^((1 << (i & 7)) - 1))
			operator := "="
			if i%8 != 0 {
				operator = "|="
			}

			begin := i - from
			end := nextI - from
			fieldStr := ""

			j := begin
			if j < end {
				nextJ := min(end, (j+8)&(^7))
				fieldMask := ((1 << (((nextJ - 1) & 7) + 1)) - 1) & (^((1 << (j & 7)) - 1))
				shiftRight := j % 8
				fieldStr += fmt.Sprintf("(((%s) & 0b%b) >> %d)", fieldData(j/8), fieldMask, shiftRight)
				j = nextJ
			}
			if j < end {
				nextJ := min(end, (j+8)&(^7))
				fieldMask := ((1 << (((nextJ - 1) & 7) + 1)) - 1) & (^((1 << (j & 7)) - 1))
				shiftLeft := 8 - nextJ%8
				fieldStr += fmt.Sprintf(" | (((%s) & 0b%b) << %d)", fieldData(j/8), fieldMask, shiftLeft)
				j = nextJ
			}

			shiftLeft := i % 8
			encodeStr += fmt.Sprintf("((uint8_t*)data)[%d] %s ((%s << %d) & 0b%b);\n", i/8, operator, fieldStr, shiftLeft, dataMask)
		}
		return encodeStr
	}

	str := fmt.Sprintf("// Encoder: %s\n", structDef.StructName)
	str += fmt.Sprintf("static void %s_Encode(struct %s* structPtr, void* data) {\n", structDef.StructName, structDef.StructName)
	encodeStr := ""
	startBits := int64(0)
	for _, field := range structDef.StructFields {
		from := startBits
		to := startBits + field.GetFieldBitSize()
		startBits += field.GetFieldBitSize()
		pos := fmt.Sprintf("[%s, %s)", util.ToSizeString(from), util.ToSizeString(to))
		switch val := field.(type) {
		case *definition.ConstantField:
			encodeStr += fmt.Sprintf("// %s %s\n", pos, val.ShortString())
			var byteOrder binary.ByteOrder = binary.LittleEndian
			if option, ok := val.FieldOptions.Get("order"); ok {
				if option.OptionValue.GetLiteralValue() == "big" {
					byteOrder = binary.BigEndian
				}
			}
			buffer := &bytes.Buffer{}
			value := val.FieldConstant.GetLiteralValueIn(val.FieldType)
			err := binary.Write(buffer, byteOrder, value)
			if err != nil {
				panic(fmt.Errorf("internal error: %s", err))
			}
			data := buffer.Bytes()
			fieldData := func(i int64) string {
				return fmt.Sprintf("0x%X", data[i])
			}
			encodeStr += genEncode(from, to, fieldData)

		case *definition.VoidField:
			encodeStr += fmt.Sprintf("// %s %s\n", pos, val.ShortString())
			encodeStr += genEncode(from, to, func(i int64) string { return "0" })

		case *definition.EmbeddedField:
			continue

		case *definition.NormalField:
			encodeStr += fmt.Sprintf("// %s %s\n", pos, val.ShortString())
			switch ty := val.FieldType.(type) {
			case *definition.Struct:
				encodeStr += fmt.Sprintf("%s_Encode(&(structPtr->%s), ((uint8_t*)data) + %d);\n", ty.StructName, val.FieldName, from/8)
			case *definition.BasicType, *definition.Enum:
				tySize := (ty.GetTypeBitSize() + 7) / 8
				fieldSize := (val.FieldBitSize + 7) / 8
				var fieldData func(int64) string
				// 默认编码为小端序
				if option, ok := val.FieldOptions.Get("order"); ok {
					if option.OptionValue.GetLiteralValue() == "big" {
						// 大端序
						fieldData = func(i int64) string {
							return fmt.Sprintf("((*(uint%d_t*)(&(structPtr->%s))) >> %d)", tySize*8, val.FieldName, (fieldSize-i-1)*8)
						}
					}
				}
				if fieldData == nil {
					// 小端序
					fieldData = func(i int64) string {
						return fmt.Sprintf("((*(uint%d_t*)(&(structPtr->%s))) >> %d)", tySize*8, val.FieldName, i*8)
					}
				}
				encodeStr += genEncode(from, to, fieldData)

			case *definition.Array:
				tySize := (ty.ElementType.GetTypeBitSize() + 7) / 8
				var fieldData func(int64) string
				// 默认编码为小端序
				if option, ok := val.FieldOptions.Get("order"); ok {
					if option.OptionValue.GetLiteralValue() == "big" {
						// 大端序
						fieldData = func(i int64) string {
							return fmt.Sprintf("((*(uint%d_t*)(&((structPtr->%s)[%d]))) >> %d)", tySize*8, val.FieldName, i/tySize, (tySize-i%tySize-1)*8)
						}
					}
				}
				if fieldData == nil {
					// 小端序
					fieldData = func(i int64) string {
						return fmt.Sprintf("((*(uint%d_t*)(&((structPtr->%s)[%d]))) >> %d)", tySize*8, val.FieldName, i/tySize, i%tySize*8)
					}
				}
				encodeStr += genEncode(from, to, fieldData)

			default:
				fieldData := func(i int64) string {
					return fmt.Sprintf("((uint8_t*)&(structPtr->%s))[%d]", val.FieldName, i)
				}
				encodeStr += genEncode(from, to, fieldData)
			}
		default:
			panic("unreachable")
		}
	}
	encodeStr = util.IndentSpace4(encodeStr)
	str += encodeStr
	str += fmt.Sprintf("}\n")
	return str
}

func (g *CMinimalGenerator) generateDecoder(structDef *definition.Struct) string {
	genDecode := func(from, to int64, fieldProcessor func(string, int64) string) string {
		decodeStr := ""
		for i := int64(0); i < to-from; i += 8 {
			nextI := min(to-from, (i+8)&(^7))
			// dataMask := ((1 << (((nextI - 1) & 7) + 1)) - 1) & (^((1 << (i & 7)) - 1))

			begin := from + i
			end := from + nextI
			fieldStr := ""

			j := begin
			if j < end {
				nextJ := min(end, (j+8)&(^7))
				fieldMask := ((1 << (((nextJ - 1) & 7) + 1)) - 1) & (^((1 << (j & 7)) - 1))
				shiftLeft := j % 8
				fieldStr += fmt.Sprintf("((((uint8_t*)data)[%d] & 0b%b) >> %d)", j/8, fieldMask, shiftLeft)
				j = nextJ
			}
			if j < end {
				nextJ := min(end, (j+8)&(^7))
				fieldMask := ((1 << (((nextJ - 1) & 7) + 1)) - 1) & (^((1 << (j & 7)) - 1))
				shiftRight := 8 - nextJ%8
				fieldStr += fmt.Sprintf(" | ((((uint8_t*)data)[%d] & 0b%b) << %d)", j/8, fieldMask, shiftRight)
				j = nextJ
			}

			decodeStr += fmt.Sprintf("%s;\n", fieldProcessor(fieldStr, i/8))
		}
		return decodeStr
	}

	signExtend := func(from, to int64, fieldStr string) string {
		if from >= to {
			return fieldStr
		}
		return fmt.Sprintf("((int%d_t)((%s) << %d) >> %d)", to, fieldStr, to-from, to-from)
	}

	// another sign extend implementation
	// signExtend2 := func(from, to int64, fieldStr string) string {
	// 	if from >= to {
	// 		return fieldStr
	// 	}
	// 	signMask := int64(1) << (from - 1)
	// 	return fmt.Sprintf("((%s ^ 0x%X) - 0x%X)", fieldStr, signMask, signMask)
	// }

	str := fmt.Sprintf("// Decoder: %s\n", structDef.StructName)
	str += fmt.Sprintf("static bool %s_Decode(void* data, struct %s* structPtr) {\n", structDef.StructName, structDef.StructName)
	decodeStr := ""
	startBits := int64(0)
	for fieldIndex, field := range structDef.StructFields {
		from := startBits
		to := startBits + field.GetFieldBitSize()
		startBits += field.GetFieldBitSize()
		pos := fmt.Sprintf("[%s, %s)", util.ToSizeString(from), util.ToSizeString(to))
		switch val := field.(type) {
		case *definition.ConstantField:
			decodeStr += fmt.Sprintf("// %s %s\n", pos, val.ShortString())
			name := fmt.Sprintf("structPtr->%s", val.FieldName)
			if val.FieldName == "" {
				tyStr, _ := g.generateType(val.FieldType)
				name = fmt.Sprintf("temp_field_%d", fieldIndex)
				decodeStr += fmt.Sprintf("%s %s;\n", tyStr, name)
			}

			tySize := (val.FieldType.GetTypeBitSize() + 7) / 8
			fieldSize := (val.FieldBitSize + 7) / 8
			var fieldProcessor func(string, int64) string
			// 默认解码为小端序
			if option, ok := val.FieldOptions.Get("order"); ok {
				if option.OptionValue.GetLiteralValue() == "big" {
					// 大端序
					fieldProcessor = func(fieldStr string, i int64) string {
						operator := "="
						if i != 0 {
							operator = "|="
						}
						return fmt.Sprintf("(*(uint%d_t*)(&(%s))) %s ((uint%d_t)(%s) << %d)", tySize*8, name, operator, tySize*8, fieldStr, (fieldSize-i-1)*8)
					}
				}
			}
			if fieldProcessor == nil {
				// 小端序
				fieldProcessor = func(fieldStr string, i int64) string {
					operator := "="
					if i != 0 {
						operator = "|="
					}
					return fmt.Sprintf("(*(uint%d_t*)(&(%s))) %s ((uint%d_t)(%s) << %d)", tySize*8, name, operator, tySize*8, fieldStr, i*8)
				}
			}
			decodeStr += genDecode(from, to, fieldProcessor)

			if val.FieldType.TypeTypeID.IsInt() && val.FieldType.TypeBitSize > val.FieldBitSize {
				decodeStr += fmt.Sprintf("%s = %s;\n", name, signExtend(val.FieldBitSize, val.FieldType.TypeBitSize, name))
			}

			decodeStr += fmt.Sprintf("if (%s != %s) return false;\n", name, val.FieldConstant)

		case *definition.VoidField:
			decodeStr += fmt.Sprintf("// %s %s\n", pos, val.ShortString())
			continue

		case *definition.EmbeddedField:
			continue

		case *definition.NormalField:
			decodeStr += fmt.Sprintf("// %s %s\n", pos, val.ShortString())
			name := fmt.Sprintf("structPtr->%s", val.FieldName)

			switch ty := val.FieldType.(type) {
			case *definition.Struct:
				decodeStr += fmt.Sprintf("if (!%s_Decode((void*)((uint8_t*)data + %d), &(%s))) return false;\n", ty.StructName, from/8, name)

			case *definition.BasicType, *definition.Enum:
				tySize := (ty.GetTypeBitSize() + 7) / 8
				fieldSize := (val.FieldBitSize + 7) / 8
				var fieldProcessor func(string, int64) string
				// 默认解码为小端序
				if option, ok := val.FieldOptions.Get("order"); ok {
					if option.OptionValue.GetLiteralValue() == "big" {
						// 大端序
						fieldProcessor = func(fieldStr string, i int64) string {
							operator := "="
							if i != 0 {
								operator = "|="
							}
							return fmt.Sprintf("(*(uint%d_t*)(&(%s))) %s ((uint%d_t)(%s) << %d)", tySize*8, name, operator, tySize*8, fieldStr, (fieldSize-i-1)*8)
						}
					}
				}
				if fieldProcessor == nil {
					// 小端序
					fieldProcessor = func(fieldStr string, i int64) string {
						operator := "="
						if i != 0 {
							operator = "|="
						}
						return fmt.Sprintf("(*(uint%d_t*)(&(%s))) %s ((uint%d_t)(%s) << %d)", tySize*8, name, operator, tySize*8, fieldStr, i*8)
					}
				}
				decodeStr += genDecode(from, to, fieldProcessor)

				if basicTy, ok := ty.(*definition.BasicType); ok {
					if basicTy.TypeTypeID.IsInt() && basicTy.TypeBitSize > val.FieldBitSize {
						decodeStr += fmt.Sprintf("%s = %s;\n", name, signExtend(val.FieldBitSize, basicTy.TypeBitSize, name))
					}
				}

			case *definition.Array:
				tySize := (ty.ElementType.GetTypeBitSize() + 7) / 8
				fieldSize := (val.FieldBitSize + 7) / 8
				var fieldProcessor func(string, int64) string
				// 默认解码为小端序
				if option, ok := val.FieldOptions.Get("order"); ok {
					if option.OptionValue.GetLiteralValue() == "big" {
						// 大端序
						fieldProcessor = func(fieldStr string, i int64) string {
							elemName := fmt.Sprintf("(%s)[%d]", name, i/tySize)
							operator := "="
							if i%tySize != 0 {
								operator = "|="
							}
							shiftLeft := (fieldSize/ty.Length - i%tySize - 1) * 8
							return fmt.Sprintf("(*(uint%d_t*)(&(%s))) %s ((uint%d_t)(%s) << %d)", tySize*8, elemName, operator, tySize*8, fieldStr, shiftLeft)
						}
					}
				}
				if fieldProcessor == nil {
					// 小端序
					fieldProcessor = func(fieldStr string, i int64) string {
						elemName := fmt.Sprintf("(%s)[%d]", name, i/tySize)
						operator := "="
						if i%tySize != 0 {
							operator = "|="
						}
						shiftLeft := (i % tySize) * 8
						return fmt.Sprintf("(*(uint%d_t*)(&(%s))) %s ((uint%d_t)(%s) << %d)", tySize*8, elemName, operator, tySize*8, fieldStr, shiftLeft)
					}
				}
				decodeStr += genDecode(from, to, fieldProcessor)

				if basicTy, ok := ty.ElementType.(*definition.BasicType); ok {
					if basicTy.TypeTypeID.IsInt() && basicTy.TypeBitSize > val.FieldBitSize {
						for i := int64(0); i < ty.Length; i++ {
							elemName := fmt.Sprintf("(%s)[%d]", name, i)
							decodeStr += fmt.Sprintf("%s = %s;\n", elemName, signExtend(val.FieldBitSize, basicTy.TypeBitSize, elemName))
						}
					}
				}

			default:
				fieldProcessor := func(fieldStr string, i int64) string {
					operator := "="
					return fmt.Sprintf("((uint8_t*)&(structPtr->%s))[%d] %s %s", val.FieldName, i, operator, fieldStr)
				}
				decodeStr += genDecode(from, to, fieldProcessor)
			}

		default:
			panic("unreachable")
		}
	}
	decodeStr += "return true;\n"
	decodeStr = util.IndentSpace4(decodeStr)
	str += decodeStr
	str += "}\n"
	return str
}

func (g *CMinimalGenerator) generateMethods(structDef *definition.Struct, fieldDef *definition.NormalField) string {

	structTypeStr := fmt.Sprintf("struct %s*", structDef.StructName)

	genGet := func(name string, retType definition.Type, expr definition.Expr) string {
		str := fmt.Sprintf("// Getter: %s_%s\n", structDef.StructName, name)
		retTypeStr, _ := g.generateType(retType)
		str += fmt.Sprintf("static %s %s_%s(%s value) {\n", retTypeStr, structDef.StructName, name, structTypeStr)
		exprStr := g.generateExpr(expr, fmt.Sprintf("value->%s", fieldDef.FieldName))
		exprStr = fmt.Sprintf("return %s;\n", exprStr)
		exprStr = util.IndentSpace4(exprStr)
		str += exprStr
		str += fmt.Sprintf("}\n")
		return str
	}

	genSet := func(name string, paramType definition.Type, expr definition.Expr) string {
		str := fmt.Sprintf("// Setter: %s_%s\n", structDef.StructName, name)
		paramTypeStr, _ := g.generateType(paramType)
		str += fmt.Sprintf("static void %s_%s(%s structPtr, %s value) {\n", structDef.StructName, name, structTypeStr, paramTypeStr)
		exprStr := g.generateExpr(expr, "value")
		exprStr = fmt.Sprintf("%s = %s;\n", fmt.Sprintf("structPtr->%s", fieldDef.FieldName), exprStr)
		exprStr = util.IndentSpace4(exprStr)
		str += exprStr
		str += fmt.Sprintf("}\n")
		return str
	}

	if fieldDef.FieldMethods == nil {
		return ""
	}

	str := fmt.Sprintf("// Methods: %s\n", fieldDef.ShortString())
	for _, method := range fieldDef.FieldMethods {
		switch method.MethodKind {
		case definition.MethodKindID_Get:
			var name string
			if method.MethodName == "" {
				name = fmt.Sprintf("Get_%s", fieldDef.FieldName)
			} else {
				name = fmt.Sprintf("Get_%s_%s", fieldDef.FieldName, method.MethodName)
			}
			str += genGet(name, method.MethodParamType, method.MethodExpr) + "\n"
		case definition.MethodKindID_Set:
			var name string
			if method.MethodName == "" {
				name = fmt.Sprintf("Set_%s", fieldDef.FieldName)
			} else {
				name = fmt.Sprintf("Set_%s_%s", fieldDef.FieldName, method.MethodName)
			}
			str += genSet(name, method.MethodParamType, method.MethodExpr) + "\n"
		default:
			panic("unreachable")
		}
	}
	return str
}

func (g *CMinimalGenerator) generateExpr(expr definition.Expr, valueReplacement string) string {
	switch val := expr.(type) {
	case *definition.UnopExpr:
		return fmt.Sprintf("(%s%s)", val.Op, g.generateExpr(val.Expr1, valueReplacement))
	case *definition.BinopExpr:
		switch val.Op {
		case definition.ExprOp_POW:
			return fmt.Sprintf("pow(%s, %s)", g.generateExpr(val.Expr1, valueReplacement), g.generateExpr(val.Expr2, valueReplacement))
		default:
			return fmt.Sprintf("(%s %s %s)", g.generateExpr(val.Expr1, valueReplacement), val.Op, g.generateExpr(val.Expr2, valueReplacement))
		}
	case *definition.CastExpr:
		tyStr, _ := g.generateType(val.ToType)
		return fmt.Sprintf("(%s)(%s)", tyStr, g.generateExpr(val.Expr1, valueReplacement))
	case *definition.TenaryExpr:
		return fmt.Sprintf("(%s ? %s : %s)", g.generateExpr(val.Cond, valueReplacement), g.generateExpr(val.Expr1, valueReplacement), g.generateExpr(val.Expr2, valueReplacement))
	case *definition.ConstantExpr:
		return fmt.Sprintf("%s", val.ConstantValue)
	case *definition.ValueExpr:
		return valueReplacement
	default:
		panic("unreachable")
	}
}

func (g *CMinimalGenerator) generateEnum(enumDef *definition.Enum) string {
	str := fmt.Sprintf("// Enum: %s\n", enumDef.ShortString())
	str += fmt.Sprintf("enum %s {\n", enumDef.EnumName)
	for _, value := range enumDef.EnumValues {
		valueStr := fmt.Sprintf("%s = %d,\n", value.EnumValueName, value.EnumValue)
		str += util.IndentSpace4(valueStr)
	}
	str += "}"
	return str
}

package cpp

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"text/template"

	"github.com/xaxys/bubbler/definition"
	"github.com/xaxys/bubbler/generator/gen"
	"github.com/xaxys/bubbler/util"
)

type GeneratedUnit struct {
	SourceUnit     *definition.CompilationUnit
	GeneratedTypes *util.OrderedMap[string, *GeneratedType]
}

type GeneratedType struct {
	GeneratedDef     string
	GeneratedFuncDef string
}

// ==================== Cpp Generator ====================

type CppGeneratorState struct {
	UseMathH     bool
	UseStringH   bool
	UseStdLibH   bool
	UseBytesType bool
}

func NewCppGeneratorState() *CppGeneratorState {
	return &CppGeneratorState{
		UseMathH:     false,
		UseStringH:   false,
		UseStdLibH:   false,
		UseBytesType: false,
	}
}

type CppGenerator struct {
	*gen.GenDispatcher
	GenCtx   *gen.GenCtx
	GenUnits *util.OrderedMap[string, *GeneratedUnit]
	GenTypes *util.OrderedMap[string, *GeneratedType]
	GenStack *util.OrderedMap[string, any]
	GenState *CppGeneratorState
	Warning  definition.TopLevelWarning
}

func NewCppGenerator() *CppGenerator {
	generator := &CppGenerator{
		GenDispatcher: nil,
		GenUnits:      util.NewOrderedMap[string, *GeneratedUnit](),
		GenTypes:      util.NewOrderedMap[string, *GeneratedType](),
		GenStack:      util.NewOrderedMap[string, any](),
		GenState:      NewCppGeneratorState(),
		Warning:       nil,
	}
	generator.GenDispatcher = gen.NewGenDispatcher(generator)
	return generator
}

// ==================== Util ====================

func (g *CppGenerator) generateDec(value any) string {
	return fmt.Sprintf("%d", value)
}

func (g *CppGenerator) generateHex(value any) string {
	if g.GenCtx.GenOptions.DecimalNumber {
		return fmt.Sprintf("%d", value)
	}
	return fmt.Sprintf("0x%X", value)
}

func (g *CppGenerator) generateBin(value any) string {
	if g.GenCtx.GenOptions.DecimalNumber {
		return fmt.Sprintf("%d", value)
	}
	return fmt.Sprintf("0b%b", value)
}

// ==================== Generate ====================

func (g *CppGenerator) Generate(ctx *gen.GenCtx) (retErr error, retWarnings error) {
	g.GenCtx = ctx
	if ctx.GenOptions.InnerClass {
		warn := &definition.GenerateWarning{
			Warning: &definition.OptionNotAvailableWarning{
				OptionName: "inner",
				Reason:     "C++ target does not support inner class, the option will be ignored",
			},
		}
		g.Warning = definition.TopLevelWarningsJoin(g.Warning, warn)
	}
	if ctx.GenOptions.MemoryCopy {
		g.GenState.UseStdLibH = true
	}

	var topErr definition.TopLevelError
	genErr := g.AcceptGenCtx(ctx)
	if genErr != nil {
		if _, ok := genErr.(definition.TopLevelError); !ok {
			genErr = &definition.GenerateError{
				Err: genErr,
			}
		}
		topErr = definition.TopLevelErrorsJoin(topErr, genErr.(definition.TopLevelError))
	}

	// generate single file
	if g.GenCtx.GenOptions.SingleFile {
		singleData := map[string]any{
			"GenUnits":     g.GenUnits,
			"UseMathH":     g.GenState.UseMathH,
			"UseStringH":   g.GenState.UseStringH,
			"UseStdLibH":   g.GenState.UseStdLibH,
			"UseBytesType": g.GenState.UseBytesType,
		}

		singleStr := util.ExecuteTemplate(fileTemplate, "singleFile", nil, singleData)
		err := g.GenCtx.WriteFile("", singleStr)
		if err != nil {
			topErr = definition.TopLevelErrorsJoin(topErr, &definition.GenerateError{
				Err: err,
			})
		}
	}

	return topErr, g.Warning
}

// ==================== GenerateUnit ====================

var fileTemplate = `
{{- define "headerFile" -}}
{{- $allCapName := ToALLCAP_CASE (.Unit.Package.ToPath "_" "") -}}
// Target: C++ (header)
// Generated by bubbler
// DO NOT EDIT
#pragma once
#ifndef __{{ $allCapName }}_BB_HPP
#define __{{ $allCapName }}_BB_HPP

#include <cstdbool>
#include <cstddef>
#include <cstdint>
{{- if .UseStdLibH }}
#include <cstdlib>
{{- end }}
{{- if .UseStringH }}
#include <cstring>
{{- end }}
{{- if .UseStringH }}
#include <string>
{{- end }}

{{ if .UseBytesType -}}
#include <memory>
#ifndef __BYTES_TYPE
#define __BYTES_TYPE
struct bytes {
    ::std::shared_ptr<uint8_t[]> data;
    uint64_t length;
};
#endif

{{ end -}}

{{ $curUnit := .Unit -}}
{{ if gt $curUnit.LocalImports.Len 0 -}}
{{ range $unit := $curUnit.LocalImports.Values -}}
#include "{{ $unit.Package.ToFilePath ".bb.hpp" }}"
{{ end }}
{{ end -}}

{{- if .Unit.Options.Has "cpp_namespace" }}
{{- $namespace0 := .Unit.Options.MustGet "cpp_namespace" }}
{{- $namespace1 := slice $namespace0.OptionValue 1 -1 -}}
namespace {{ $namespace1 }}
{
{{ else -}}
namespace {{ .Unit.Package.ToPath "::" "" }}
{
{{ end -}}

    {{ range $entry := .GenTypes.Entries -}}
    {{- $type := $entry.Value }}
    /* ====================== {{ $entry.Key }} ====================== */
    {{- if $type.GeneratedDef }}
    {{ $type.GeneratedDef }};
    {{ end }}
    /* ==================== End {{ $entry.Key }} ==================== */

{{ end }}
{{- if .Unit.Options.Has "cpp_namespace" }}
{{- $namespace0 := .Unit.Options.MustGet "cpp_namespace" }}
{{- $namespace1 := slice $namespace0.OptionValue 1 -1 -}}
} // namespace {{ $namespace1 }}

{{ else -}}
} // namespace {{ .Unit.Package.ToPath "::" "" }}

{{ end -}}
#endif // __{{ $allCapName }}_BB_HPP
{{ end }}

{{- define "sourceFile" -}}
// Target: C++ (source)
// Generated by bubbler
// DO NOT EDIT
{{- if .UseMathH }}
#include <cmath>
{{- end }}

#include "{{ .Unit.Package.ToFilePath ".bb.hpp" }}"

{{- if .Unit.Options.Has "cpp_namespace" }}
{{- $namespace0 := .Unit.Options.MustGet "cpp_namespace" }}
{{- $namespace1 := slice $namespace0.OptionValue 1 -1 }}

namespace {{ $namespace1 }}
{
{{ else }}

namespace {{ .Unit.Package.ToPath "::" "" }}
{
{{ end -}}

    {{ range $entry := .GenTypes.Entries -}}
    {{- $type := $entry.Value }}
    /* ====================== {{ $entry.Key }} ====================== */
    {{ if $type.GeneratedFuncDef }}
    {{ $type.GeneratedFuncDef }}
    {{ end }}
    /* ==================== End {{ $entry.Key }} ==================== */

{{ end }}
{{- if .Unit.Options.Has "cpp_namespace" }}
{{- $namespace0 := .Unit.Options.MustGet "cpp_namespace" }}
{{- $namespace1 := slice $namespace0.OptionValue 1 -1 -}}
} // namespace {{ $namespace1 }}
{{ else -}}
} // namespace {{ .Unit.Package.ToPath "::" "" }}
{{ end -}}
{{- end -}}

{{- define "singleFile" -}}
// Target: C++ (single file)
// Generated by bubbler
// DO NOT EDIT
#include <cstdbool>
#include <cstddef>
#include <cstdint>
{{- if .UseStdLibH }}
#include <cstdlib>
{{- end }}
{{- if .UseStringH }}
#include <cstring>
{{- end }}
{{- if .UseMathH }}
#include <cmath>
{{- end }}
{{- if .UseStringH }}
#include <string>
{{- end }}

{{ if .UseBytesType -}}
#include <memory>
#ifndef __BYTES_TYPE
#define __BYTES_TYPE
struct bytes {
    ::std::shared_ptr<uint8_t[]> data;
    uint64_t length;
};
#endif

{{ end -}}

{{ range $genUnit := .GenUnits.Values -}}
{{- $unit := $genUnit.SourceUnit }}
{{- if $unit.Options.Has "cpp_namespace" }}
{{- $namespace0 := $unit.Options.MustGet "cpp_namespace" }}
{{- $namespace1 := slice $namespace0.OptionValue 1 -1 -}}
namespace {{ $namespace1 }}
{
{{ else -}}
namespace {{ $unit.Package.ToPath "::" "" }}
{
{{ end -}}

    {{ range $entry := $genUnit.GeneratedTypes.Entries -}}
    {{- $type := $entry.Value }}
    /* ====================== {{ $entry.Key }} ====================== */
    {{- if $type.GeneratedDef }}
    {{ $type.GeneratedDef }};
    {{ end }}
    /* ==================== End {{ $entry.Key }} ==================== */

{{ end }}

{{- if $unit.Options.Has "cpp_namespace" }}
{{- $namespace0 := $unit.Options.MustGet "cpp_namespace" }}
{{- $namespace1 := slice $namespace0.OptionValue 1 -1 -}}
} // namespace {{ $namespace1 }}

{{ else -}}
} // namespace {{ $unit.Package.ToPath "::" "" }}

{{ end -}}
{{ end -}}
{{- end -}}
`

func (g CppGenerator) GenerateUnit(unit *definition.CompilationUnit) error {
	if unit.LocalTypes.Len() == 0 && gen.MatchOption(unit.Options, "omit_empty", true) {
		return nil
	}

	genUnit := &GeneratedUnit{
		SourceUnit:     unit,
		GeneratedTypes: util.NewOrderedMap[string, *GeneratedType](),
	}

	g.GenUnits.Put(unit.Package.String(), genUnit)

	start := g.GenTypes.Len()

	for _, type_ := range unit.LocalTypes.Values() {
		_, err := g.GenerateType(type_)
		if err != nil {
			return err
		}
	}

	end := g.GenTypes.Len()

	genTypes := g.GenTypes.Sub(start, end)
	genUnit.GeneratedTypes = genTypes

	// do not generate file if single file
	if g.GenCtx.GenOptions.SingleFile {
		return nil
	}

	headerData := map[string]any{
		"Unit":         unit,
		"GenTypes":     genTypes,
		"UseStringH":   g.GenState.UseStringH,
		"UseStdLibH":   g.GenState.UseStdLibH,
		"UseBytesType": g.GenState.UseBytesType,
	}

	headerStr := util.ExecuteTemplate(fileTemplate, "headerFile", nil, headerData)
	err := g.GenCtx.WritePackage(unit.Package, ".bb.hpp", headerStr)
	if err != nil {
		return err
	}

	sourceData := map[string]any{
		"Unit":     unit,
		"GenTypes": genTypes,
		"UseMathH": g.GenState.UseMathH,
	}
	sourceStr := util.ExecuteTemplate(fileTemplate, "sourceFile", nil, sourceData)
	err = g.GenCtx.WritePackage(unit.Package, ".bb.cpp", sourceStr)
	if err != nil {
		return err
	}

	// clear state for next unit
	g.GenState = NewCppGeneratorState()

	return nil
}

// ==================== GenerateType ====================

func (g CppGenerator) GenerateType(type_ definition.Type) (string, error) {
	return g.AcceptType(type_)
}

// ==================== GenerateTypeDefaultValue ====================

func (g CppGenerator) GenerateTypeDefaultValue(type_ definition.Type) (string, error) {
	return g.AcceptTypeDefaultValue(type_)
}

// ==================== GenerateBasicType ====================

var typeMap = map[definition.TypeID]string{
	definition.TypeID_Bool:    "bool",
	definition.TypeID_Uint8:   "uint8_t",
	definition.TypeID_Uint16:  "uint16_t",
	definition.TypeID_Uint32:  "uint32_t",
	definition.TypeID_Uint64:  "uint64_t",
	definition.TypeID_Int8:    "int8_t",
	definition.TypeID_Int16:   "int16_t",
	definition.TypeID_Int32:   "int32_t",
	definition.TypeID_Int64:   "int64_t",
	definition.TypeID_Float32: "float",
	definition.TypeID_Float64: "double",
}

func (g CppGenerator) GenerateBasicType(type_ *definition.BasicType) (string, error) {
	if str, ok := typeMap[type_.TypeTypeID]; ok {
		return str, nil
	}
	return "", fmt.Errorf("unknown basic type: %s", type_.String())
}

// ==================== GenerateBasicTypeDefaultValue ====================

var typeDefValueMap = map[definition.TypeID]string{
	definition.TypeID_Bool:    "false",
	definition.TypeID_Uint8:   "0",
	definition.TypeID_Uint16:  "0",
	definition.TypeID_Uint32:  "0",
	definition.TypeID_Uint64:  "0",
	definition.TypeID_Int8:    "0",
	definition.TypeID_Int16:   "0",
	definition.TypeID_Int32:   "0",
	definition.TypeID_Int64:   "0",
	definition.TypeID_Float32: "0.0f",
	definition.TypeID_Float64: "0.0",
}

func (g CppGenerator) GenerateBasicTypeDefaultValue(type_ *definition.BasicType) (string, error) {
	if str, ok := typeDefValueMap[type_.TypeTypeID]; ok {
		return str, nil
	}
	return "", fmt.Errorf("unknown basic type: %s", type_.String())
}

// ==================== GenerateString ====================

func (g CppGenerator) GenerateString(string_ *definition.String) (string, error) {
	g.GenState.UseStringH = true
	return "::std::string", nil
}

// ==================== GenerateStringDefaultValue ====================

func (g CppGenerator) GenerateStringDefaultValue(string_ *definition.String) (string, error) {
	return `""`, nil
}

// ==================== GenerateBytes ====================

func (g CppGenerator) GenerateBytes(bytes *definition.Bytes) (string, error) {
	g.GenState.UseStringH = true
	g.GenState.UseBytesType = true
	return "struct ::bytes", nil
}

// ==================== GenerateBytesDefaultValue ====================

func (g CppGenerator) GenerateBytesDefaultValue(bytes *definition.Bytes) (string, error) {
	return "nullptr", nil
}

// ==================== GenerateArray ====================

func (g CppGenerator) GenerateArray(array *definition.Array) (string, error) {
	panic("unreachable, array type should be handled in GenerateStruct")
}

// ==================== GenerateArrayDefaultValue ====================

func (g CppGenerator) GenerateArrayDefaultValue(array *definition.Array) (string, error) {
	panic("unreachable, array type should be handled in GenerateStructDefaultValue")
}

// ==================== GenerateStruct ====================

var structTemplate = `
{{- define "field" -}}
    // {{ .Pos }} {{ .Field.GetFieldKind }}: {{ .Field }}
    {{- $fieldStrLen := len .FieldStr -}}
    {{- if gt $fieldStrLen 0 }}
        {{ .FieldStr }}
    {{- end }}
{{- end -}}

{{- define "structConst" -}}
        static constexpr bool dynamic = {{ if .StructDef.StructDynamic }}true{{ else }}false{{ end }};
        static constexpr uint64_t size = {{ calc .StructDef.StructBitSize "/" 8 }};
{{- end -}}

{{- define "structDef" -}}
{{- $structDef := .StructDef -}}
{{- $fieldStrs := .FieldStrs -}}
    // Struct: {{ $structDef }}
    struct {{ $structDef.StructName }} {
        {{- range $fieldStr := $fieldStrs }}
        {{ $fieldStr }}
        {{- end }}

        {{ .StructConstStr }}
        {{- if .GenOption.SingleFile }}

    {{ template "structFuncDef" . }}
        {{- else }}
        {{ template "structFuncDecl" . }}
        {{- end }}
    }
{{- end -}}

{{- define "structFuncDecl" -}}
        {{ range $methodDeclStr := .MethodDeclStrs }}
        {{ $methodDeclStr }}
        {{- end }}
        {{ .EncoderDeclStr }}
        {{ .DecoderDeclStr }}
{{- end -}}

{{- define "structFuncDef" -}}
    {{ range $methodStr := .MethodStrs -}}
    {{ $methodStr }}

    {{ end -}}
    {{ .EncoderStr }}

    {{ .DecoderStr }}
{{- end -}}
`

func (g CppGenerator) GenerateStruct(structDef *definition.Struct) (string, error) {
	name := fmt.Sprintf("struct %s::%s", structDef.StructBelongs.Package.ToPath("::", ""), structDef.StructName)
	// check if this struct is already generated
	if g.GenTypes.Has(structDef.StructName) {
		return name, nil
	}
	// check if this struct is in generating
	if g.GenStack.Has(structDef.StructName) {
		return name, nil
	}
	// push to stack
	g.GenStack.Put(structDef.StructName, nil)
	defer g.GenStack.Remove(structDef.StructName)

	genTy, err := g.generateStruct(structDef)
	if err != nil {
		return "", err
	}
	g.GenTypes.Put(structDef.StructName, genTy)

	return name, nil
}

func (g CppGenerator) generateStruct(structDef *definition.Struct) (*GeneratedType, error) {
	fieldStrs := make([]string, structDef.StructFields.Len())
	if err := structDef.ForEachFieldWithPos(func(field definition.Field, index int, start int64, dynamic bool, pos string) error {
		fieldStr, err := g.GenerateField(field)
		if err != nil {
			return err
		}

		fieldData := map[string]any{
			"Pos":      pos,
			"Field":    field,
			"FieldStr": fieldStr,
		}

		str := util.ExecuteTemplate(structTemplate, "field", nil, fieldData)
		fieldStrs[index] = str
		return nil
	}); err != nil {
		return nil, err
	}

	methodStrs := []string{}
	methodDeclStrs := []string{}
	if err := structDef.ForEachField(func(field definition.Field, index int, start int64, dynamic bool) error {
		if !field.GetFieldKind().IsNormal() {
			return nil
		}
		normalField := field.(*definition.NormalField)
		for _, group := range normalField.FieldMethods.Values() {
			for _, method := range group.Values() {
				methodStr, err := g.GenerateMethod(method)
				if err != nil {
					return err
				}

				methodDeclStr, err := g.GenerateMethodDecl(method)
				if err != nil {
					return err
				}

				methodStrs = append(methodStrs, methodStr)
				methodDeclStrs = append(methodDeclStrs, methodDeclStr)
			}
		}

		if !g.GenCtx.GenOptions.MinimalCode {
			rawGetterStr, err := g.GenerateRawGetter(field)
			if err != nil {
				return err
			}

			rawGetterDeclStr, err := g.GenerateRawGetterDecl(field)
			if err != nil {
				return err
			}

			methodStrs = append(methodStrs, rawGetterStr)
			methodDeclStrs = append(methodDeclStrs, rawGetterDeclStr)

			rawSetterStr, err := g.GenerateRawSetter(field)
			if err != nil {
				return err
			}

			rawSetterDeclStr, err := g.GenerateRawSetterDecl(field)
			if err != nil {
				return err
			}

			methodStrs = append(methodStrs, rawSetterStr)
			methodDeclStrs = append(methodDeclStrs, rawSetterDeclStr)
		}
		return nil
	}); err != nil {
		return nil, err
	}

	constData := map[string]any{
		"StructDef": structDef,
	}
	constStr := util.ExecuteTemplate(structTemplate, "structConst", nil, constData)

	encoderDeclStr, err := g.GenerateEncoderDecl(structDef)
	if err != nil {
		return nil, err
	}

	decoderDeclStr, err := g.GenerateDecoderDecl(structDef)
	if err != nil {
		return nil, err
	}

	encoderStr, err := g.GenerateEncoder(structDef)
	if err != nil {
		return nil, err
	}

	decoderStr, err := g.GenerateDecoder(structDef)
	if err != nil {
		return nil, err
	}

	funcDefData := map[string]any{
		"MethodStrs": methodStrs,
		"EncoderStr": encoderStr,
		"DecoderStr": decoderStr,
	}

	funcDefStr := util.ExecuteTemplate(structTemplate, "structFuncDef", nil, funcDefData)

	if g.GenCtx.GenOptions.SingleFile {
		for i, methodStr := range methodStrs {
			methodStrs[i] = util.IndentSpace4(methodStr)
		}
		encoderStr = util.IndentSpace4(encoderStr)
		decoderStr = util.IndentSpace4(decoderStr)
	}

	defData := map[string]any{
		"StructDef":      structDef,
		"FieldStrs":      fieldStrs,
		"StructConstStr": constStr,
		"MethodDeclStrs": methodDeclStrs,
		"EncoderDeclStr": encoderDeclStr,
		"DecoderDeclStr": decoderDeclStr,
		"MethodStrs":     methodStrs,
		"EncoderStr":     encoderStr,
		"DecoderStr":     decoderStr,
		"GenOption":      g.GenCtx.GenOptions,
	}

	defStr := util.ExecuteTemplate(structTemplate, "structDef", nil, defData)

	code := &GeneratedType{
		GeneratedDef:     defStr,
		GeneratedFuncDef: funcDefStr,
	}
	return code, nil
}

// ==================== GenerateStructDefaultValue ====================

func (g CppGenerator) GenerateStructDefaultValue(structDef *definition.Struct) (string, error) {
	return "{}", nil
}

// ==================== GenerateField ====================

func (g CppGenerator) GenerateField(field definition.Field) (string, error) {
	return g.AcceptField(field)
}

// ==================== GenerateNormalField ====================

var normalFieldTemplate = `
{{- define "normalField" -}}
    {{- $field := .Field -}}
    {{- $fieldName := Tosnake_case .Field.FieldName -}}
    {{ if $field.FieldType.GetTypeID.IsArray }}
        {{- $elemType := $field.FieldType.ElementType -}}
        {{- $tyStr := GenerateType $elemType -}}
        {{- $length := $field.FieldType.Length -}}
        {{ $tyStr }} {{ $fieldName }}[{{ $length }}];
    {{- else }}
        {{- $tyStr := GenerateType $field.FieldType -}}
        {{ $tyStr }} {{ $fieldName }};
    {{- end -}}
{{- end -}}
`

func (g CppGenerator) GenerateNormalField(field *definition.NormalField) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
	}

	fieldData := map[string]any{
		"Field": field,
	}

	fieldStr := util.ExecuteTemplate(normalFieldTemplate, "normalField", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateVoidField ====================

func (g CppGenerator) GenerateVoidField(field *definition.VoidField) (string, error) {
	return "", nil
}

// ==================== GenerateEmbeddedField ====================

func (g CppGenerator) GenerateEmbeddedField(field *definition.EmbeddedField) (string, error) {
	return "", nil
}

// ==================== GenerateConstantField ====================

var constantFieldTemplate = `
{{- define "constantField" -}}
    {{- $field := .Field -}}
    {{- $fieldName := Tosnake_case .Field.FieldName -}}
    {{- if $fieldName -}}
        {{- $tyStr := GenerateType $field.FieldType -}}
        {{ $tyStr }} {{ $fieldName }};
    {{- end }}
{{- end -}}
`

func (g CppGenerator) GenerateConstantField(field *definition.ConstantField) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
	}

	fieldData := map[string]any{
		"Field": field,
	}

	fieldStr := util.ExecuteTemplate(constantFieldTemplate, "constantField", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateMethod ====================

func (g CppGenerator) GenerateMethod(method definition.Method) (string, error) {
	return g.AcceptMethod(method)
}

// ==================== GenerateMethodDecl ====================

func (g CppGenerator) GenerateMethodDecl(method definition.Method) (string, error) {
	return g.AcceptMethodDecl(method)
}

// ==================== GenerateDefaultGetterDecl ====================

var defaultGetterDeclTemplate = `
{{- define "defaultGetterDecl" -}}
{{- $retTyStr := GenerateType .MethodDef.MethodRetType -}}
{{- $field := .MethodDef.MethodBelongs -}}
{{- $fieldName := Tosnake_case $field.FieldName -}}
{{- $structName := $field.FieldBelongs.StructName -}}
        // DefaultGetterDecl: get_{{ $fieldName }}
        {{ if .GenOption.SingleFile }}static {{ end -}}
        const {{ $retTyStr }}& get_{{ $fieldName }}() const;
{{- end -}}
`

func (g CppGenerator) GenerateDefaultGetterDecl(method *definition.GetMethod) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
	}

	fieldData := map[string]any{
		"MethodDef": method,
		"GenOption": g.GenCtx.GenOptions,
	}
	fieldStr := util.ExecuteTemplate(defaultGetterDeclTemplate, "defaultGetterDecl", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateDefaultSetterDecl ====================

var defaultSetterDeclTemplate = `
{{- define "defaultSetterDecl" -}}
{{- $paramTyStr := GenerateType .MethodDef.MethodParamType -}}
{{- $field := .MethodDef.MethodBelongs -}}
{{- $fieldName := Tosnake_case $field.FieldName -}}
{{- $structName := $field.FieldBelongs.StructName -}}
        // DefaultSetterDecl: set_{{ $fieldName }}
        {{ if .GenOption.SingleFile }}static {{ end -}}
        void set_{{ $fieldName }}({{ $paramTyStr }} value);
{{- end -}}
`

func (g CppGenerator) GenerateDefaultSetterDecl(method *definition.SetMethod) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
	}

	fieldData := map[string]any{
		"MethodDef": method,
		"GenOption": g.GenCtx.GenOptions,
	}
	fieldStr := util.ExecuteTemplate(defaultSetterDeclTemplate, "defaultSetterDecl", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateCustomGetterDecl ====================

var customGetterDeclTemplate = `
{{- define "customGetterDecl" -}}
{{- $methodName := Tosnake_case .MethodDef.MethodName -}}
{{- $retTyStr := GenerateType .MethodDef.MethodRetType -}}
{{- $field := .MethodDef.MethodBelongs -}}
{{- $fieldName := Tosnake_case $field.FieldName -}}
{{- $structName := $field.FieldBelongs.StructName -}}
{{- $methodName := Tosnake_case .MethodDef.MethodName -}}
        // CustomGetterDecl: get_{{ $methodName }}
        {{ $retTyStr }} get_{{ $methodName }}() const;
{{- end -}}
`

func (g CppGenerator) GenerateCustomGetterDecl(method *definition.GetMethod) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
	}

	fieldData := map[string]any{
		"MethodDef": method,
	}
	fieldStr := util.ExecuteTemplate(customGetterDeclTemplate, "customGetterDecl", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateCustomSetterDecl ====================

var customSetterDeclTemplate = `
{{- define "customSetterDecl" -}}
{{- $methodName := Tosnake_case .MethodDef.MethodName -}}
{{- $paramTyStr := GenerateType .MethodDef.MethodParamType -}}
{{- $field := .MethodDef.MethodBelongs -}}
{{- $fieldName := Tosnake_case $field.FieldName -}}
{{- $structName := $field.FieldBelongs.StructName -}}
{{- $methodName := Tosnake_case .MethodDef.MethodName -}}
        // CustomSetterDecl: set_{{ $methodName }}
        void set_{{ $methodName }}({{ $paramTyStr }} value);
{{- end -}}
`

func (g CppGenerator) GenerateCustomSetterDecl(method *definition.SetMethod) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
	}

	fieldData := map[string]any{
		"MethodDef": method,
	}
	fieldStr := util.ExecuteTemplate(customSetterDeclTemplate, "customSetterDecl", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateRawGetterDecl ====================

var rawGetterDeclTemplate = `
{{- define "rawGetterDecl" -}}
{{- $retTyStr := GenerateType .FieldDef.FieldType -}}
{{- $fieldName := Tosnake_case .FieldDef.FieldName -}}
{{- $structName := .FieldDef.FieldBelongs.StructName -}}
        // RawGetterDecl: get_{{ $fieldName }}
        const {{ $retTyStr }}& get_{{ $fieldName }}() const;
{{- end -}}

{{- define "rawGetterArrayDecl" -}}
{{- $elemTyStr := GenerateType .FieldDef.FieldType.ElementType -}}
{{- $fieldName := Tosnake_case .FieldDef.FieldName -}}
{{- $structName := .FieldDef.FieldBelongs.StructName -}}
        // RawGetterArrayDecl: get_{{ $fieldName }}
        const {{ $elemTyStr }}* get_{{ $fieldName }}() const;
        // RawGetterArrayItemDecl: get_{{ $fieldName }}_item
        const {{ $elemTyStr }}& get_{{ $fieldName }}_item(uint64_t index) const;
        // RawGetterArrayLengthDecl: get_{{ $fieldName }}_length
        uint64_t get_{{ $fieldName }}_length() const;
{{- end -}}

{{- define "rawGetterDeclSelector" -}}
{{- if .FieldDef.FieldType.GetTypeID.IsArray }}
    {{- template "rawGetterArrayDecl" . }}
{{- else }}
    {{- template "rawGetterDecl" . }}
{{- end -}}
{{- end -}}
`

func (g CppGenerator) GenerateRawGetterDecl(field definition.Field) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
	}

	fieldData := map[string]any{
		"FieldDef": field,
	}
	fieldStr := util.ExecuteTemplate(rawGetterDeclTemplate, "rawGetterDeclSelector", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateRawSetterDecl ====================

var rawSetterDeclTemplate = `
{{- define "rawSetterDecl" -}}
{{- $paramTyStr := GenerateType .FieldDef.FieldType -}}
{{- $fieldName := Tosnake_case .FieldDef.FieldName -}}
{{- $structName := .FieldDef.FieldBelongs.StructName -}}
        // RawSetterDecl: set_{{ $fieldName }}
        void set_{{ $fieldName }}({{ $paramTyStr }} value);
{{- end -}}

{{- define "rawSetterArrayDecl" -}}
{{- $elemTyStr := GenerateType .FieldDef.FieldType.ElementType -}}
{{- $fieldName := Tosnake_case .FieldDef.FieldName -}}
{{- $structName := .FieldDef.FieldBelongs.StructName -}}
        // RawSetterArrayDecl: set_{{ $fieldName }}
        void set_{{ $fieldName }}(const {{ $elemTyStr }}* value, uint64_t length);
        // RawSetterArrayItemDecl: set_{{ $fieldName }}_item
        void set_{{ $fieldName }}_item(uint64_t index, const {{ $elemTyStr }}& value);
{{- end -}}

{{- define "rawSetterDeclSelector" -}}
{{- if .FieldDef.FieldType.GetTypeID.IsArray }}
    {{- template "rawSetterArrayDecl" . }}
{{- else }}
    {{- template "rawSetterDecl" . }}
{{- end -}}
{{- end -}}
`

func (g CppGenerator) GenerateRawSetterDecl(field definition.Field) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
	}

	fieldData := map[string]any{
		"FieldDef": field,
	}
	fieldStr := util.ExecuteTemplate(rawSetterDeclTemplate, "rawSetterDeclSelector", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateDefaultGetter ====================

// TODO: support default getter

var defaultGetterTemplate = `
{{- define "defaultGetter" -}}
{{- $retTyStr := GenerateType .MethodDef.MethodRetType -}}
{{- $field := .MethodDef.MethodBelongs -}}
{{- $fieldName := Tosnake_case $field.FieldName -}}
{{- $structName := $field.FieldBelongs.StructName -}}
{{- $valueStr := printf "this->%s" $fieldName -}}
{{- $exprStr := GenerateExpr .MethodDef.MethodExpr $valueStr -}}
    // DefaultGetter: {{ $structName }}::get_{{ $fieldName }}
    const {{ $retTyStr }}& {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}get_{{ $fieldName }}() const {
        return {{ $exprStr }};
    }
{{- end -}}
`

func (g CppGenerator) GenerateDefaultGetter(method *definition.GetMethod) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
		"GenerateExpr": g.GenerateExpr,
	}

	fieldData := map[string]any{
		"MethodDef": method,
		"GenOption": g.GenCtx.GenOptions,
	}
	fieldStr := util.ExecuteTemplate(defaultGetterTemplate, "defaultGetter", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateDefaultSetter ====================

// TODO: support default setter

var defaultSetterTemplate = `
{{- define "defaultSetter" -}}
{{- $paramTyStr := GenerateType .MethodDef.MethodParamType -}}
{{- $field := .MethodDef.MethodBelongs -}}
{{- $fieldName := Tosnake_case $field.FieldName -}}
{{- $structName := $field.FieldBelongs.StructName -}}
{{- $exprStr := GenerateExpr .MethodDef.MethodExpr "value" -}}
    // DefaultSetter: {{ $structName }}::set_{{ $fieldName }}
    void {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}set_{{ $fieldName }}({{ $paramTyStr }} value) {
        this->{{ $fieldName }} = {{ $exprStr }};
    }
{{- end -}}
`

func (g CppGenerator) GenerateDefaultSetter(method *definition.SetMethod) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
		"GenerateExpr": g.GenerateExpr,
	}

	fieldData := map[string]any{
		"MethodDef": method,
		"GenOption": g.GenCtx.GenOptions,
	}
	fieldStr := util.ExecuteTemplate(defaultSetterTemplate, "defaultSetter", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateCustomGetter ====================

var customGetterTemplate = `
{{- define "customGetter" -}}
{{- $retTyStr := GenerateType .MethodDef.MethodRetType -}}
{{- $field := .MethodDef.MethodBelongs -}}
{{- $fieldName := Tosnake_case $field.FieldName -}}
{{- $structName := $field.FieldBelongs.StructName -}}
{{- $methodName := Tosnake_case .MethodDef.MethodName -}}
{{- $valueStr := printf "this->%s" $fieldName -}}
{{- $exprStr := GenerateExpr .MethodDef.MethodExpr $valueStr -}}
    // CustomGetter: {{ $structName }}::get_{{ $methodName }}
    {{ $retTyStr }} {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}get_{{ $methodName }}() const {
        return {{ $exprStr }};
    }
{{- end -}}
`

func (g CppGenerator) GenerateCustomGetter(method *definition.GetMethod) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
		"GenerateExpr": g.GenerateExpr,
	}

	fieldData := map[string]any{
		"MethodDef": method,
		"GenOption": g.GenCtx.GenOptions,
	}
	fieldStr := util.ExecuteTemplate(customGetterTemplate, "customGetter", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateCustomSetter ====================

var customSetterTemplate = `
{{- define "customSetter" -}}
{{- $paramTyStr := GenerateType .MethodDef.MethodParamType -}}
{{- $field := .MethodDef.MethodBelongs -}}
{{- $fieldName := Tosnake_case $field.FieldName -}}
{{- $structName := $field.FieldBelongs.StructName -}}
{{- $methodName := Tosnake_case .MethodDef.MethodName -}}
{{- $exprStr := GenerateExpr .MethodDef.MethodExpr "value" -}}
    // CustomSetter: {{ $structName }}::set_{{ $methodName }}
    void {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}set_{{ $methodName }}({{ $paramTyStr }} value) {
        this->{{ $fieldName }} = {{ $exprStr }};
    }
{{- end -}}
`

func (g CppGenerator) GenerateCustomSetter(method *definition.SetMethod) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
		"GenerateExpr": g.GenerateExpr,
	}

	fieldData := map[string]any{
		"MethodDef": method,
		"GenOption": g.GenCtx.GenOptions,
	}
	fieldStr := util.ExecuteTemplate(customSetterTemplate, "customSetter", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateRawGetter ====================

var rawGetterTemplate = `
{{- define "rawGetter" -}}
{{- $retTyStr := GenerateType .FieldDef.FieldType -}}
{{- $field := .FieldDef -}}
{{- $fieldName := Tosnake_case $field.FieldName -}}
{{- $structName := $field.FieldBelongs.StructName -}}
    // RawGetter: {{ $structName }}::get_{{ $fieldName }}
    const {{ $retTyStr }}& {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}get_{{ $fieldName }}() const {
        return this->{{ $fieldName }};
    }
{{- end -}}

{{- define "rawGetterArray" -}}
{{- $elemTyStr := GenerateType .FieldDef.FieldType.ElementType -}}
{{- $length := .FieldDef.FieldType.Length -}}
{{- $fieldName := Tosnake_case .FieldDef.FieldName -}}
{{- $structName := .FieldDef.FieldBelongs.StructName -}}
    // RawGetterArray: {{ $structName }}::get_{{ $fieldName }}
    const {{ $elemTyStr }}* {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}get_{{ $fieldName }}() const {
        return this->{{ $fieldName }};
    }

    // RawGetterArrayItem: {{ $structName }}::get_{{ $fieldName }}_item
    const {{ $elemTyStr }}& {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}get_{{ $fieldName }}_item(uint64_t index) const {
        return this->{{ $fieldName }}[index];
    }

    // RawGetterArrayLength: {{ $structName }}::get_{{ $fieldName }}_length
    uint64_t {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}get_{{ $fieldName }}_length() const {
        return {{ $length }};
    }
{{- end -}}

{{- define "rawGetterSelector" -}}
{{- if .FieldDef.FieldType.GetTypeID.IsArray }}
    {{- template "rawGetterArray" . }}
{{- else }}
    {{- template "rawGetter" . }}
{{- end -}}
{{- end -}}
`

func (g CppGenerator) GenerateRawGetter(field definition.Field) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
	}

	fieldData := map[string]any{
		"FieldDef":  field,
		"GenOption": g.GenCtx.GenOptions,
	}
	fieldStr := util.ExecuteTemplate(rawGetterTemplate, "rawGetterSelector", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateRawSetter ====================

var rawSetterTemplate = `
{{- define "rawSetter" -}}
{{- $paramTyStr := GenerateType .FieldDef.FieldType -}}
{{- $fieldName := Tosnake_case .FieldDef.FieldName -}}
{{- $structName := .FieldDef.FieldBelongs.StructName -}}
    // RawSetter: {{ $structName }}::set_{{ $fieldName }}
    void {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}set_{{ $fieldName }}({{ $paramTyStr }} value) {
        this->{{ $fieldName }} = value;
    }
{{- end -}}

{{- define "rawSetterArray" -}}
{{- $elemTyStr := GenerateType .FieldDef.FieldType.ElementType -}}
{{- $length := .FieldDef.FieldType.Length -}}
{{- $fieldName := Tosnake_case .FieldDef.FieldName -}}
{{- $structName := .FieldDef.FieldBelongs.StructName -}}
    // RawSetterArray: {{ $structName }}::set_{{ $fieldName }}
    void {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}set_{{ $fieldName }}(const {{ $elemTyStr }}* value, uint64_t length) {
    {{- range $i := iterate 0 $length }}
        this->{{ $fieldName }}[{{ $i }}] = value[{{ $i }}];
    {{- end }}
    }

    // RawSetterArrayItem: {{ $structName }}::set_{{ $fieldName }}_item
    void {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}set_{{ $fieldName }}_item(uint64_t index, const {{ $elemTyStr }}& value) {
        this->{{ $fieldName }}[index] = value;
    }
{{- end -}}

{{- define "rawSetterSelector" -}}
{{- if .FieldDef.FieldType.GetTypeID.IsArray }}
    {{- template "rawSetterArray" . }}
{{- else }}
    {{- template "rawSetter" . }}
{{- end -}}
{{- end -}}
`

func (g CppGenerator) GenerateRawSetter(field definition.Field) (string, error) {
	funcMap := template.FuncMap{
		"GenerateType": g.GenerateType,
	}

	fieldData := map[string]any{
		"FieldDef":  field,
		"GenOption": g.GenCtx.GenOptions,
	}
	fieldStr := util.ExecuteTemplate(rawSetterTemplate, "rawSetterSelector", funcMap, fieldData)
	return fieldStr, nil
}

// ==================== GenerateEnum ====================

func (g CppGenerator) GenerateEnum(enumDef *definition.Enum) (string, error) {
	name := fmt.Sprintf("enum %s::%s", enumDef.EnumBelongs.Package.ToPath("::", ""), enumDef.EnumName)
	// check if this enum is already generated
	if g.GenTypes.Has(enumDef.EnumName) {
		return name, nil
	}
	// check if this enum is in generating
	if g.GenStack.Has(enumDef.EnumName) {
		return name, nil
	}
	// push to stack
	g.GenStack.Put(enumDef.EnumName, nil)
	defer g.GenStack.Remove(enumDef.EnumName)

	genTy, err := g.generateEnum(enumDef)
	if err != nil {
		return "", err
	}
	g.GenTypes.Put(enumDef.EnumName, genTy)

	return name, nil
}

var enumTemplate = `
{{- define "enumDef" -}}
    // Enum: {{ .EnumDef.ShortString }}
    enum class {{ .EnumDef.EnumName }} : {{ .TyUint }} {
    {{- range .EnumDef.EnumValues.Values }}
        {{ .EnumValueName }} = {{ .EnumValue }},
    {{- end }}
    }
{{- end -}}
`

func (g CppGenerator) generateEnum(enumDef *definition.Enum) (*GeneratedType, error) {
	enumSize := (enumDef.EnumBitSize + 7) / 8
	tySize := util.HighBit(enumSize)
	tyUint := typeSizeToUintStr(tySize * 8)
	enumDefData := map[string]any{
		"EnumDef": enumDef,
		"TyUint":  tyUint,
	}
	enumDefStr := util.ExecuteTemplate(enumTemplate, "enumDef", nil, enumDefData)

	code := &GeneratedType{
		GeneratedDef:     enumDefStr,
		GeneratedFuncDef: "",
	}

	return code, nil
}

// ==================== GenerateEnumDefaultValue ====================

func (g CppGenerator) GenerateEnumDefaultValue(enumDef *definition.Enum) (string, error) {
	return "0", nil
}

// ==================== GenerateEncoderDecl ====================

var encoderDeclTemplate = `
{{- define "encoderDecl" -}}
{{- $structName := .StructDef.StructName -}}
        // EncodeSizeDecl: encode_size
        {{ if not .StructDef.StructDynamic -}}constexpr {{ end -}}
        uint64_t encode_size() const;
        // EncoderDecl: encode
        uint64_t encode(void* data) const;
{{- end -}}
`

func (g CppGenerator) GenerateEncoderDecl(structDef *definition.Struct) (string, error) {
	fieldData := map[string]any{
		"StructDef": structDef,
		"GenOption": g.GenCtx.GenOptions,
	}
	fieldStr := util.ExecuteTemplate(encoderDeclTemplate, "encoderDecl", nil, fieldData)
	return fieldStr, nil
}

// ==================== GenerateDecoderDecl ====================

var decoderDeclTemplate = `
{{- define "decoderDecl" -}}
{{- $structName := .StructDef.StructName -}}
        // DecoderDecl: decode
        uint64_t decode(void* data);
{{- end -}}
`

func (g CppGenerator) GenerateDecoderDecl(structDef *definition.Struct) (string, error) {
	fieldData := map[string]any{
		"StructDef": structDef,
		"GenOption": g.GenCtx.GenOptions,
	}
	fieldStr := util.ExecuteTemplate(decoderDeclTemplate, "decoderDecl", nil, fieldData)
	return fieldStr, nil
}

// ==================== Encode/Decode Util ====================

var typeSizeMapUint = map[int64]definition.TypeID{
	8:  definition.TypeID_Uint8,
	16: definition.TypeID_Uint16,
	32: definition.TypeID_Uint32,
	64: definition.TypeID_Uint64,
}

var typeSizeMapInt = map[int64]definition.TypeID{
	8:  definition.TypeID_Int8,
	16: definition.TypeID_Int16,
	32: definition.TypeID_Int32,
	64: definition.TypeID_Int64,
}

func typeSizeToUintStr(size int64) string {
	ty := typeSizeMapUint[size]
	return typeMap[ty]
}

func typeSizeToIntStr(size int64) string {
	ty := typeSizeMapInt[size]
	return typeMap[ty]
}

// ==================== GenerateEncoder ====================

var encoderTemplate = `
{{- define "encodeField" -}}
        // {{ .Pos }} {{ .Field.GetFieldKind }}: {{ .Field }}
        {{- range $encodeStmt := .EncodeStmts }}
        {{ $encodeStmt }}
        {{- end -}}
{{- end -}}

{{- define "encoder" -}}
{{- $structName := .StructDef.StructName -}}
    // EncodeSize: {{ $structName }}::encode_size
    {{ if not .StructDef.StructDynamic -}}constexpr {{ end -}}
    uint64_t {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}encode_size() const {
        {{- if .StructDef.StructDynamic }}
        uint64_t size = {{ calc .StructDef.StructBitSize "/" 8 }};
        {{- range $field := .StructDef.StructFields.Values }}
            {{- if $field.GetFieldKind.IsNormal }}
            {{- $fieldName := Tosnake_case $field.FieldName }}
                {{- if $field.FieldType.GetTypeID.IsArray }}
                    {{- if $field.FieldType.ElementType.GetTypeID.IsStruct }}
                        {{- if $field.FieldType.ElementType.GetTypeDynamic }}
                            {{- range $i := iterate 0 $field.FieldType.Length }}
        size += this->{{ $fieldName }}[{{ $i }}].encode_size();
                            {{- end }}
                        {{- end }}
                    {{- else if $field.FieldType.ElementType.GetTypeID.IsString }}
                        {{- range $i := iterate 0 $field.FieldType.Length }}
        size += this->{{ $fieldName }}[{{ $i }}].size() + 1;
                        {{- end }}
                    {{- else if $field.FieldType.ElementType.GetTypeID.IsBytes }}
                        {{- range $i := iterate 0 $field.FieldType.Length }}
        size += this->{{ $fieldName }}[{{ $i }}].length;
        size += 1{{ range $j := iterate 1 10 }} + static_cast<bool>(this->{{ $fieldName }}[{{ $i }}].length >> {{ calc $j "*" 7 }}){{ end }};
                        {{- end }}
                    {{- end }}
                {{- else if $field.FieldType.GetTypeID.IsStruct }}
                    {{- if $field.FieldType.GetTypeDynamic }}
        size += this->{{ $fieldName }}.encode_size();
                    {{- end }}
                {{- else if $field.FieldType.GetTypeID.IsString }}
        size += this->{{ $fieldName }}.size() + 1;
                {{- else if $field.FieldType.GetTypeID.IsBytes }}
        size += this->{{ $fieldName }}.length;
        size += 1{{ range $j := iterate 1 10 }} + static_cast<bool>(this->{{ $fieldName }}.length >> {{ calc $j "*" 7 }}){{ end }};
                {{- end }}
            {{- end }}
        {{- end }}
        return size;
        {{- else }}
        return {{ calc .StructDef.StructBitSize "/" 8 }};
        {{- end }}
    }

    // Encoder: {{ $structName }}::encode
    uint64_t {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}encode(void* data) const {
        {{- if .Dynamic }}
        uint64_t offset = 0;
        {{- end }}
        {{- range $encodeStr := .EncodeStrs }}
        {{ $encodeStr }}
        {{- end }}
        return {{ if .Dynamic }}offset + {{ end }}{{ calc .StructDef.StructBitSize "/" 8 }};
    }
{{- end -}}
`

func (g CppGenerator) GenerateEncoder(structDef *definition.Struct) (string, error) {
	encodeStrs := []string{}
	if err := structDef.ForEachFieldWithPos(func(field definition.Field, fieldIndex int, startBits int64, dynamic bool, pos string) error {
		encodeStmts, err := g.generateEncodeField(field, startBits)
		if err != nil {
			return err
		}
		// skip
		if len(encodeStmts) == 0 {
			return nil
		}
		// remove blank lines
		filteredEncodeStmts := []string{}
		for _, stmt := range encodeStmts {
			if stmt != "" {
				filteredEncodeStmts = append(filteredEncodeStmts, stmt)
			}
		}
		encodeStmts = filteredEncodeStmts

		encodeFieldData := map[string]any{
			"Pos":         pos,
			"Field":       field,
			"EncodeStmts": encodeStmts,
		}

		str := util.ExecuteTemplate(encoderTemplate, "encodeField", nil, encodeFieldData)
		encodeStrs = append(encodeStrs, str)
		return nil
	}); err != nil {
		return "", err
	}

	fieldData := map[string]any{
		"StructDef":  structDef,
		"EncodeStrs": encodeStrs,
		"GenOption":  g.GenCtx.GenOptions,
		"Dynamic":    structDef.GetTypeDynamic(),
	}

	encoderStr := util.ExecuteTemplate(encoderTemplate, "encoder", nil, fieldData)
	return encoderStr, nil
}

// return multiple statements (lines) to encode a field
func (g CppGenerator) generateEncodeField(field definition.Field, startBits int64) ([]string, error) {
	switch val := field.(type) {
	case *definition.ConstantField:
		return g.generateEncodeConstantField(val, startBits)
	case *definition.VoidField:
		return g.generateEncodeVoidField(val, startBits)
	case *definition.EmbeddedField:
		return g.generateEncodeEmbeddedField(val, startBits)
	case *definition.NormalField:
		return g.generateEncodeNormalField(val, startBits)
	default:
		return nil, fmt.Errorf("internal error: unknown field kind %T", val)
	}
}

var fieldEncoderTemplate = `
{{- define "encodeTempVarName" -}}
    temp_field_at_pos_{{ .StartBits }}
{{- end -}}

{{- define "encodeStructFieldName" -}}
{{- $fieldName := Tosnake_case .FieldName -}}
    this->{{ $fieldName }}
{{- end -}}

{{- define "encodeNormalFieldStruct" -}}
    {{ if .FieldStruct.GetTypeDynamic }}offset += {{ end }}{{ .FieldName }}.encode(static_cast<{{ .TyUint8 }}*>(data) + {{ if .Dynamic }}offset + {{ end }}{{ .FromByte }});
{{- end -}}

{{- define "encodeNormalFieldTempVarDecl" -}}
    {{ .TyUint }} {{ .TempName }} = static_cast<{{ .TyUint }}>({{ .FieldName }});
{{- end -}}

{{- define "encodeNormalFieldTempVarDeclOnly" -}}
    {{ .TyUint }} {{ .TempName }};
{{- end -}}

{{- define "encodeNormalFieldTempVarAssign" -}}
    {{ .TempName }} = static_cast<{{ .TyUint }}>({{ .FieldName }});
{{- end -}}

{{- define "encodeNormalFieldCast" -}}
    (*reinterpret_cast<const {{ .TyUint }}*>(&({{ .FieldName }})))
{{- end -}}

{{- define "encodeNormalFieldString" -}}
        {
            uint64_t {{ .TempName }} = {{ .FieldName }}.size();
            memcpy(static_cast<{{ .TyUint8 }}*>(data) + offset + {{ .FromByte }}, {{ .FieldName }}.data(), {{ .TempName }});
            static_cast<{{ .TyUint8 }}*>(data)[offset + {{ .FromByte }} + {{ .TempName }}] = 0;
            offset += {{ .TempName }} + 1;
        }
{{- end -}}

{{- define "encodeNormalFieldBytes" -}}
{{- $fieldLengthName := printf "(%s).length" .FieldName -}}
{{- $fieldDataName := printf "(%s).data" .FieldName -}}
        {
            uint64_t {{ .TempName }} = {{ $fieldLengthName }};
            do static_cast<{{ .TyUint8 }}*>(data)[offset + {{ .FromByte }}] = (({{ .TempName }} & {{ .GetMask }}) | {{ .SetMask }}), {{ .TempName }} >>= {{ .Shift }}, offset++; while ({{ .TempName }});
            static_cast<{{ .TyUint8 }}*>(data)[offset - 1 + {{ .FromByte }}] &= ~{{ .SetMask }};
            memcpy(static_cast<{{ .TyUint8 }}*>(data) + offset + {{ .FromByte }}, {{ $fieldDataName }}.get(), {{ $fieldLengthName }});
            offset += {{ $fieldLengthName }};
        }
{{- end -}}

{{- define "encodeImpl" -}}
    static_cast<{{ .TyUint8 }}*>(data)[{{ if .Dynamic }}offset + {{ end }}{{ .BytePos }}] {{ .Operator }} {{ .FieldData }};
{{- end -}}
`

func (g CppGenerator) generateEncodeTempVarName(startBits int64) string {
	encodeTempVarNameData := map[string]any{
		"StartBits": startBits,
	}

	return util.ExecuteTemplate(fieldEncoderTemplate, "encodeTempVarName", nil, encodeTempVarNameData)
}

func (g CppGenerator) generateEncodeStructFieldName(name string) string {
	encodeStructFieldNameData := map[string]any{
		"FieldName": name,
	}

	return util.ExecuteTemplate(fieldEncoderTemplate, "encodeStructFieldName", nil, encodeStructFieldNameData)
}

func (g CppGenerator) generateEncodeConstantField(field *definition.ConstantField, startBits int64) ([]string, error) {
	structDynamic := field.FieldBelongs.GetTypeDynamic()
	var byteOrder binary.ByteOrder = binary.LittleEndian
	if gen.MatchOption(field.FieldOptions, "order", "big") {
		byteOrder = binary.BigEndian
	}

	buffer := &bytes.Buffer{}
	value := field.FieldConstant.GetLiteralValueIn(field.FieldType.TypeTypeID)
	err := binary.Write(buffer, byteOrder, value)
	if err != nil {
		return nil, fmt.Errorf("internal error: %s", err)
	}

	data := buffer.Bytes()
	fieldData := func(i int64) string {
		return g.generateHex(data[i])
	}

	from := startBits
	to := startBits + field.GetFieldBitSize()

	encodeStmts := g.generateEncodeImpl(from, to, fieldData, structDynamic)
	return encodeStmts, nil
}

func (g CppGenerator) generateEncodeVoidField(field *definition.VoidField, startBits int64) ([]string, error) {
	return []string{""}, nil
}

func (g CppGenerator) generateEncodeEmbeddedField(field *definition.EmbeddedField, startBits int64) ([]string, error) {
	return nil, nil
}

func (g CppGenerator) generateEncodeNormalField(field *definition.NormalField, startBits int64) ([]string, error) {
	from := startBits
	to := startBits + field.GetFieldBitSize()
	structDynamic := field.FieldBelongs.GetTypeDynamic()
	encodeStmts := []string{}

	switch ty := field.FieldType.(type) {
	case *definition.Struct, *definition.BasicType, *definition.String, *definition.Bytes:
		name := g.generateEncodeStructFieldName(field.FieldName)
		stmts, err := g.generateEncodeNormalFieldImpl(name, ty, field.FieldOptions, structDynamic, from, to)
		if err != nil {
			return nil, err
		}
		encodeStmts = append(encodeStmts, stmts...)

	case *definition.Enum:
		fieldBitSize := field.GetFieldBitSize()
		fieldSize := (fieldBitSize + 7) / 8
		tySize := util.HighBit(fieldSize)
		tyUint := typeSizeToUintStr(tySize * 8)
		tyUintID := typeSizeMapUint[tySize*8]
		tempTy := definition.GetBasicType(tyUintID)
		tempName := g.generateEncodeTempVarName(startBits)

		encodeNormalFieldTempVarDeclData := map[string]any{
			"TyUint":    tyUint,
			"TempName":  tempName,
			"FieldName": g.generateEncodeStructFieldName(field.FieldName),
		}
		declStr := util.ExecuteTemplate(fieldEncoderTemplate, "encodeNormalFieldTempVarDecl", nil, encodeNormalFieldTempVarDeclData)
		encodeStmts = append(encodeStmts, declStr)

		stmts, err := g.generateEncodeNormalFieldImpl(tempName, tempTy, field.FieldOptions, structDynamic, from, to)
		if err != nil {
			return nil, err
		}
		encodeStmts = append(encodeStmts, stmts...)

	case *definition.Array:
		elemTy := ty.ElementType
		elemTySize := (ty.ElementType.GetTypeBitSize() + 7) / 8
		elemBitSize := field.FieldBitSize / ty.Length
		tyUint := typeSizeToUintStr(elemTySize * 8)
		tyUintID := typeSizeMapUint[elemTySize*8]

		name := g.generateEncodeStructFieldName(field.FieldName)

		// temp variable declaration
		var nameIndex func(int64) string
		switch ty.ElementType.(type) {
		case *definition.Struct, *definition.BasicType, *definition.String, *definition.Bytes:
			nameIndex = func(index int64) string {
				return fmt.Sprintf("((%s)[%d])", name, index)
			}
		case *definition.Enum:
			tempName := g.generateEncodeTempVarName(startBits)

			encodeNormalFieldTempVarDeclOnlyData := map[string]any{
				"TyUint":   tyUint,
				"TempName": tempName,
			}
			declStr := util.ExecuteTemplate(fieldEncoderTemplate, "encodeNormalFieldTempVarDeclOnly", nil, encodeNormalFieldTempVarDeclOnlyData)
			encodeStmts = append(encodeStmts, declStr)

			nameIndex = func(_ int64) string {
				return tempName
			}

			// change elemTy to temp variable type
			elemTy = definition.GetBasicType(tyUintID)
		default:
			return nil, fmt.Errorf("internal error: unsupported array element type %T", ty.ElementType)
		}

		for i := int64(0); i < ty.Length; i++ {
			subFrom := from + i*elemBitSize
			subTo := from + (i+1)*elemBitSize

			subName := nameIndex(i)

			switch ty.ElementType.(type) {
			case *definition.Enum:
				encodeNormalFieldTempVarAssignData := map[string]any{
					"TyUint":    tyUint,
					"TempName":  subName,
					"FieldName": fmt.Sprintf("((%s)[%d])", name, i),
				}
				assignStr := util.ExecuteTemplate(fieldEncoderTemplate, "encodeNormalFieldTempVarAssign", nil, encodeNormalFieldTempVarAssignData)
				encodeStmts = append(encodeStmts, assignStr)
			default:
			}

			stmts, err := g.generateEncodeNormalFieldImpl(subName, elemTy, field.FieldOptions, structDynamic, subFrom, subTo)
			if err != nil {
				return nil, err
			}

			encodeStmts = append(encodeStmts, stmts...)
		}

	default:
		return nil, fmt.Errorf("internal error: unknown field kind %T", ty)
	}

	return encodeStmts, nil
}

// generateEncodeNormalFieldImpl does not handle array field or generate temp variable declaration
func (g CppGenerator) generateEncodeNormalFieldImpl(fieldNameStr string, fieldType definition.Type, fieldOptions *util.OrderedMap[string, *definition.Option], structDynamic bool, from, to int64) ([]string, error) {
	encodeStmts := []string{}
	fieldBitSize := to - from

	switch ty := fieldType.(type) {
	case *definition.Struct:
		encodeNormalFieldStructData := map[string]any{
			"TyUint8":     typeMap[definition.TypeID_Uint8],
			"FieldStruct": ty,
			"FieldName":   fieldNameStr,
			"FromByte":    from / 8,
			"Dynamic":     structDynamic,
		}

		stmt := util.ExecuteTemplate(fieldEncoderTemplate, "encodeNormalFieldStruct", nil, encodeNormalFieldStructData)
		encodeStmts = append(encodeStmts, stmt)

	case *definition.Enum:
		panic("unreachable, enum field should be handled in generateEncodeNormalField")

	case *definition.String:
		encodeNormalFieldStringData := map[string]any{
			"TyUint8":   typeMap[definition.TypeID_Uint8],
			"FieldName": fieldNameStr,
			"FromByte":  from / 8,
			"TempName":  g.generateEncodeTempVarName(from),
		}

		stmt := util.ExecuteTemplate(fieldEncoderTemplate, "encodeNormalFieldString", nil, encodeNormalFieldStringData)
		encodeStmts = append(encodeStmts, stmt)

	case *definition.Bytes:
		encodeNormalFieldBytesData := map[string]any{
			"TyUint8":   typeMap[definition.TypeID_Uint8],
			"FieldName": fieldNameStr,
			"FromByte":  from / 8,
			"GetMask":   g.generateHex((1 << 7) - 1),
			"SetMask":   g.generateHex(1 << 7),
			"Shift":     7,
			"TempName":  g.generateEncodeTempVarName(from),
		}

		stmt := util.ExecuteTemplate(fieldEncoderTemplate, "encodeNormalFieldBytes", nil, encodeNormalFieldBytesData)
		encodeStmts = append(encodeStmts, stmt)

	case *definition.BasicType:
		tySize := (ty.GetTypeBitSize() + 7) / 8
		tyUint := typeSizeToUintStr(tySize * 8)
		tyUintID := typeSizeMapUint[tySize*8]

		// cast to proper unsigned type if needed
		if tyUintID != ty.GetTypeID() {
			encodeNormalFieldCastData := map[string]any{
				"TyUint":    tyUint,
				"FieldName": fieldNameStr,
			}
			castStr := util.ExecuteTemplate(fieldEncoderTemplate, "encodeNormalFieldCast", nil, encodeNormalFieldCastData)
			fieldNameStr = castStr
		}

		// little endian as default
		fieldData := func(i int64) string {
			// expr = fieldNameStr >> 8*i
			expr := &definition.BinopExpr{
				Op: definition.ExprOp_SHR,
				Expr1: &definition.RawExpr{
					Expr: fieldNameStr,
				},
				Expr2: &definition.RawExpr{
					Expr: g.generateDec(8 * i),
				},
			}
			exprStr, err := g.GenerateExpr(expr, "")
			if err != nil {
				panic(fmt.Errorf("internal error: %s", err))
			}
			return exprStr
		}
		// big endian
		if gen.MatchOption(fieldOptions, "order", "big") {
			fieldData = func(i int64) string {
				// expr = fieldNameStr >> max(0, fieldBitSize-8*(i+1))
				expr := &definition.BinopExpr{
					Op: definition.ExprOp_SHR,
					Expr1: &definition.RawExpr{
						Expr: fieldNameStr,
					},
					Expr2: &definition.RawExpr{
						Expr: g.generateDec(max(0, fieldBitSize-8*(i+1))),
					},
				}
				exprStr, err := g.GenerateExpr(expr, "")
				if err != nil {
					panic(fmt.Errorf("internal error: %s", err))
				}
				return exprStr
			}
		}
		encodeStmts = append(encodeStmts, g.generateEncodeImpl(from, to, fieldData, structDynamic)...)

	case *definition.Array:
		panic("unreachable, array field should be handled in generateEncodeNormalField")

	default:
		return nil, fmt.Errorf("internal error: unknown field kind %T", ty)
	}

	return encodeStmts, nil
}

// generateEncodeImpl generates encode implementation from 'from' bit to 'to' bit and align to 8 bits
// from: start bit position of encoded data
// to: end bit position of encoded data
// from is inclusive, to is exclusive, i.e. [from, to)
//
// e.g. from = 3, to = 11
//
//	data[0] = (data[0] & 0b00000111) | ((fieldData(0) << 3) & 0b11111000)
//	data[1] = (data[1] & 0b11111000) | ((fieldData(0) >> 5) & 0b00000111)
//
// fieldData: a function callback to get expression of x-th byte data
//
// e.g. big endian
//
//	fieldData(0) -> ((structPtr->intField >> 24) & 0xff)
//	fieldData(1) -> ((structPtr->intField >> 16) & 0xff)
//	fieldData(2) -> ((structPtr->intField >> 8) & 0xff)
//	fieldData(3) -> ((structPtr->intField >> 0) & 0xff)
func (g CppGenerator) generateEncodeImpl(from, to int64, fieldData func(int64) string, structDynamic bool) []string {
	encodeStmts := []string{}
	// generate encode implentation from 'from' bit to 'to' bit and align to 8 bits
	// e.g. from = 3, to = 11 -> loop 2 times: 3-7, 8-11
	for i := from; i < to; i = (i + 8) & (^7) {
		// nextI is the right bound of current encode expression
		// use nextI to calculate the mask of current encode expression
		nextI := min(to, (i+8)&(^7))
		dataMask := ((1 << (((nextI - 1) & 7) + 1)) - 1) & (^((1 << (i & 7)) - 1))

		// operator is '=' if is filling the whole byte, otherwise is '|='
		operator := ""
		if i%8 == 0 {
			operator = exprOpToString[definition.ExprOp_ASSIGN] // "="
		} else {
			operator = exprOpToString[definition.ExprOp_BOR] + exprOpToString[definition.ExprOp_ASSIGN] // "|="
		}

		// we use 'from' and 'to' to denote the bit position in encoded data
		// we use 'begin' and 'end' to denote the bit position in raw field data
		begin := i - from
		end := nextI - from

		var expr definition.Expr

		// 'i' is the start bit position in encoded data
		// 'j' is the start bit position in raw field data
		j := begin
		// first half
		// e.g. j = 3, end = 11
		//      j = 3, nextJ = 8, fieldMask = 0b11111000, shiftRight = 3
		if j < end {
			// nextJ is the right bound of current field data (aligned to 8 bits)
			nextJ := min(end, (j+8)&(^7))
			fieldMask := ((1 << (((nextJ - 1) & 7) + 1)) - 1) & (^((1 << (j & 7)) - 1))
			shiftRight := j % 8
			// expr = (fieldData(j/8) & fieldMask) >> j%8
			expr = &definition.BinopExpr{
				Op: definition.ExprOp_SHR,
				Expr1: &definition.BinopExpr{
					Op: definition.ExprOp_BAND,
					Expr1: &definition.RawExpr{
						Expr: fieldData(j / 8),
					},
					Expr2: &definition.RawExpr{
						Expr: g.generateBin(fieldMask),
					},
				},
				Expr2: &definition.RawExpr{
					Expr: fmt.Sprintf("%d", shiftRight),
				},
			}

			// jump to second half
			j = nextJ
		}
		// second half (if exists)
		// e.g. j = 8, end = 11
		//      j = 8, nextJ = 11, fieldMask = 0b00000111, shiftLeft = 5
		if j < end {
			nextJ := min(end, (j+8)&(^7))
			fieldMask := ((1 << (((nextJ - 1) & 7) + 1)) - 1) & (^((1 << (j & 7)) - 1))
			shiftLeft := 8 - nextJ%8
			// expr = expr | (fieldData(j/8) & fieldMask) << (8 - nextJ%8)
			expr = &definition.BinopExpr{
				Op:    definition.ExprOp_BOR,
				Expr1: expr,
				Expr2: &definition.BinopExpr{
					Op: definition.ExprOp_SHL,
					Expr1: &definition.BinopExpr{
						Op: definition.ExprOp_BAND,
						Expr1: &definition.RawExpr{
							Expr: fieldData(j / 8),
						},
						Expr2: &definition.RawExpr{
							Expr: g.generateBin(fieldMask),
						},
					},
					Expr2: &definition.RawExpr{
						Expr: fmt.Sprintf("%d", shiftLeft),
					},
				},
			}

			j = nextJ
		}

		// shift expr to match the bit position in encoded data (concerning 'i')
		shiftLeft := i % 8
		// expr = (expr << i%8) & dataMask
		expr = &definition.BinopExpr{
			Op: definition.ExprOp_BAND,
			Expr1: &definition.BinopExpr{
				Op:    definition.ExprOp_SHL,
				Expr1: expr,
				Expr2: &definition.RawExpr{
					Expr: fmt.Sprintf("%d", shiftLeft),
				},
			},
			Expr2: &definition.RawExpr{
				Expr: g.generateBin(dataMask),
			},
		}

		// generate encode expression
		exprStr, err := g.GenerateExpr(expr, "")
		if err != nil {
			panic(fmt.Errorf("internal error: %s", err))
		}

		// generate encode statement
		encodeImplData := map[string]any{
			"TyUint8":   typeMap[definition.TypeID_Uint8],
			"BytePos":   i / 8,
			"Operator":  operator,
			"FieldData": exprStr,
			"Dynamic":   structDynamic,
		}

		encodeStmt := util.ExecuteTemplate(fieldEncoderTemplate, "encodeImpl", nil, encodeImplData)
		encodeStmts = append(encodeStmts, encodeStmt)
	}
	return encodeStmts
}

// ==================== GenerateDecoder ====================

var decoderTemplate = `
{{- define "decodeField" -}}
    // {{ .Pos }} {{ .Field.GetFieldKind }}: {{ .Field }}
    {{- range $decodeStmt := .DecodeStmts }}
        {{ $decodeStmt }}
    {{- end -}}
{{- end -}}

{{- define "decoder" -}}
{{- $structName := .StructDef.StructName -}}
    // Decoder: {{ $structName }}::decode
    uint64_t {{ if not .GenOption.SingleFile }}{{ $structName }}::{{ end }}decode(void* data) {
        {{- if .Dynamic }}
        uint64_t offset = 0;
        {{- end }}
        {{- range $decodeStr := .DecodeStrs }}
        {{ $decodeStr }}
        {{- end }}
        return {{ if .Dynamic }}offset + {{ end }}{{ calc .StructDef.StructBitSize "/" 8 }};
    }
{{- end -}}
`

func (g CppGenerator) GenerateDecoder(structDef *definition.Struct) (string, error) {
	decodeStrs := []string{}
	if err := structDef.ForEachFieldWithPos(func(field definition.Field, fieldIndex int, startBits int64, dynamic bool, pos string) error {
		decodeStmts, err := g.generateDecodeField(field, startBits)
		if err != nil {
			return err
		}
		// skip
		if len(decodeStmts) == 0 {
			return nil
		}
		// remove blank lines
		filteredDecodeStmts := []string{}
		for _, stmt := range decodeStmts {
			if stmt != "" {
				filteredDecodeStmts = append(filteredDecodeStmts, stmt)
			}
		}
		decodeStmts = filteredDecodeStmts

		decodeFieldData := map[string]any{
			"Pos":         pos,
			"Field":       field,
			"DecodeStmts": decodeStmts,
		}

		str := util.ExecuteTemplate(decoderTemplate, "decodeField", nil, decodeFieldData)
		decodeStrs = append(decodeStrs, str)
		return nil
	}); err != nil {
		return "", err
	}

	fieldData := map[string]any{
		"StructDef":  structDef,
		"DecodeStrs": decodeStrs,
		"GenOption":  g.GenCtx.GenOptions,
		"Dynamic":    structDef.GetTypeDynamic(),
	}

	decoderStr := util.ExecuteTemplate(decoderTemplate, "decoder", nil, fieldData)
	return decoderStr, nil
}

func (g CppGenerator) generateDecodeField(field definition.Field, startBits int64) ([]string, error) {
	switch val := field.(type) {
	case *definition.ConstantField:
		return g.generateDecodeConstantField(val, startBits)
	case *definition.VoidField:
		return g.generateDecodeVoidField(val, startBits)
	case *definition.EmbeddedField:
		return g.generateDecodeEmbeddedField(val, startBits)
	case *definition.NormalField:
		return g.generateDecodeNormalField(val, startBits)
	default:
		return nil, fmt.Errorf("internal error: unknown field kind %T", val)
	}
}

var fieldDecoderTemplate = `
{{- define "decodeTempVarName" -}}
    temp_field_at_pos_{{ .StartBits }}
{{- end -}}

{{- define "decodeStructFieldName" -}}
{{- $fieldName := Tosnake_case .FieldName -}}
    this->{{ $fieldName }}
{{- end -}}

{{- define "decodeConstantField" -}}
    if ({{ .TempName }} != {{ .ConstantValue }}) return -1;
{{- end -}}

{{- define "decodeNormalFieldStruct" -}}
{{- if .FieldStruct.GetTypeDynamic -}}
        {
            {{ .TyUint64 }} {{ .TempName }} = {{ .FieldName }}.decode(static_cast<{{ .TyUint8 }}*>(data) + offset + {{ .FromByte }});
            if ({{ .TempName }} < 0) return -1;
            offset += {{ .TempName }};
        }
{{- else -}}
        if ({{ .FieldName }}.decode(static_cast<{{ .TyUint8 }}*>(data) + {{ if .Dynamic }}offset + {{ end }}{{ .FromByte }}) < 0) return -1;
{{- end -}}
{{- end -}}

{{- define "decodeNormalFieldTempVarDecl" -}}
    {{ .TyUint }} {{ .TempName }};
{{- end -}}

{{- define "decodeNormalFieldTempVarAssign" -}}
    {{ .FieldName }} = static_cast<{{ .TyUint }}>({{ .TempName }});
{{- end -}}

{{- define "decodeNormalFieldTempVarAssignEnum" -}}
    {{ .FieldName }} = static_cast<enum {{ .EnumDef.EnumBelongs.Package.ToPath "::" "" }}::{{ .EnumDef.EnumName }}>({{ .TempName }});
{{- end -}}

{{- define "decodeNormalFieldNoCast" -}}
    {{ .FieldName }} {{ .Operator }} {{ .Expr }};
{{- end -}}

{{- define "decodeNormalFieldCast" -}}
    *reinterpret_cast<{{ .TyUint }}*>(&({{ .FieldName }})) {{ .Operator }} {{ .Expr }};
{{- end -}}

{{- define "decodeNormalFieldString" -}}
        {
            uint64_t {{ .TempName }} = strlen(reinterpret_cast<char*>(static_cast<{{ .TyUint8 }}*>(data) + offset + {{ .FromByte }}));
            {{ .FieldName }} = {{ .TyString }}(static_cast<char*>(data) + offset + {{ .FromByte }}, {{ .TempName }});
            offset += {{ .TempName }} + 1;
        }
{{- end -}}

{{- define "decodeNormalFieldBytes" -}}
{{- $fieldLengthName := printf "(%s).length" .FieldName -}}
{{- $fieldDataName := printf "(%s).data" .FieldName -}}
        {
            uint64_t {{ .TempName }} = 0;
            {{ .TyUint8 }} shift = 0;
            while (static_cast<{{ .TyUint8 }}*>(data)[offset + {{ .FromByte }}] & {{ .SetMask }}) {{ .TempName }} |= (static_cast<{{ .TyUint8 }}*>(data)[offset + {{ .FromByte }}] & {{ .GetMask }}) << shift, shift += {{ .Shift }}, offset++;
            {{ .TempName }} |= (static_cast<{{ .TyUint8 }}*>(data)[offset + {{ .FromByte }}] & {{ .GetMask }}) << shift, offset++;
            {{ .FieldName }}.length = {{ .TempName }};
            {{ if .MemoryCopy -}}
            {{ .FieldName }}.data = ::std::shared_ptr<{{ .TyUint8 }}[]>(new {{ .TyUint8 }}[{{ .TempName }}]);
            memcpy({{ .FieldName }}.data.get(), static_cast<{{ .TyUint8 }}*>(data) + offset + {{ .FromByte }}, {{ .TempName }});
            {{ else -}}
            {{ .FieldName }}.data = ::std::shared_ptr<{{ .TyUint8 }}[]>(static_cast<{{ .TyUint8 }}*>(data) + offset + {{ .FromByte }}, []({{ .TyUint8 }}[]){});
            {{ end -}}
            offset += {{ .TempName }};
        }
{{- end -}}

{{- define "decodeData" -}}
    static_cast<{{ .TyUint8 }}*>(data)[{{ if .Dynamic }}offset + {{ end }}{{ .BytePos }}]
{{- end -}}

{{- define "signExtendShift" -}}
    {{ .FieldName }} = ({{ .TyInt }})(({{ .FieldName }}) << {{ .Shift }}) >> {{ .Shift }};
{{- end -}}

{{- define "signExtendArith" -}}
    {{ .FieldName }} = (({{ .FieldName }}) ^ {{ .SignMask }}) - {{ .SignMask }};
{{- end -}}
`

func (g CppGenerator) generateDecodeTempVarName(startBits int64) string {
	decoderTempVarNameData := map[string]any{
		"StartBits": startBits,
	}

	return util.ExecuteTemplate(fieldDecoderTemplate, "decodeTempVarName", nil, decoderTempVarNameData)
}

func (g CppGenerator) generateDecodeStructFieldName(name string) string {
	decodeStructFieldNameData := map[string]any{
		"FieldName": name,
	}

	return util.ExecuteTemplate(fieldDecoderTemplate, "decodeStructFieldName", nil, decodeStructFieldNameData)
}

func (g CppGenerator) generateDecodeConstantField(field *definition.ConstantField, startBits int64) ([]string, error) {
	structDynamic := field.FieldBelongs.GetTypeDynamic()
	decodeStmts := []string{}

	fieldBitSize := field.GetFieldBitSize()
	fieldSize := (fieldBitSize + 7) / 8
	tySize := util.HighBit(fieldSize)
	tyUint := typeSizeToUintStr(tySize * 8)
	tempName := g.generateDecodeTempVarName(startBits)

	decodeNormalFieldTempVarDeclData := map[string]any{
		"TyUint":   tyUint,
		"TempName": tempName,
	}
	declStr := util.ExecuteTemplate(fieldDecoderTemplate, "decodeNormalFieldTempVarDecl", nil, decodeNormalFieldTempVarDeclData)
	decodeStmts = append(decodeStmts, declStr)

	from := startBits
	to := startBits + fieldBitSize

	stmts, err := g.generateDecodeNormalFieldImpl(tempName, field.FieldType, field.FieldOptions, structDynamic, from, to)
	if err != nil {
		return nil, err
	}

	decodeStmts = append(decodeStmts, stmts...)

	literalValue, err := NewCLiteralGenerator().GenerateLiteral(field.FieldConstant)
	if err != nil {
		return nil, err
	}

	decodeConstantFieldData := map[string]any{
		"TempName":      tempName,
		"ConstantValue": literalValue,
	}

	checkStr := util.ExecuteTemplate(fieldDecoderTemplate, "decodeConstantField", nil, decodeConstantFieldData)
	decodeStmts = append(decodeStmts, checkStr)

	return decodeStmts, nil
}

func (g CppGenerator) generateDecodeVoidField(field *definition.VoidField, startBits int64) ([]string, error) {
	return []string{""}, nil
}

func (g CppGenerator) generateDecodeEmbeddedField(field *definition.EmbeddedField, startBits int64) ([]string, error) {
	return nil, nil
}

func (g CppGenerator) generateDecodeNormalField(field *definition.NormalField, startBits int64) ([]string, error) {
	from := startBits
	to := startBits + field.GetFieldBitSize()
	structDynamic := field.FieldBelongs.GetTypeDynamic()
	decodeStmts := []string{}

	switch ty := field.FieldType.(type) {
	case *definition.Struct, *definition.BasicType, *definition.String, *definition.Bytes:
		name := g.generateDecodeStructFieldName(field.FieldName)
		stmts, err := g.generateDecodeNormalFieldImpl(name, ty, field.FieldOptions, structDynamic, from, to)
		if err != nil {
			return nil, err
		}
		decodeStmts = append(decodeStmts, stmts...)

	case *definition.Enum:
		fieldBitSize := field.GetFieldBitSize()
		fieldSize := (fieldBitSize + 7) / 8
		tySize := util.HighBit(fieldSize)
		tyUint := typeSizeToUintStr(tySize * 8)
		tyUintID := typeSizeMapUint[tySize*8]
		tempTy := definition.GetBasicType(tyUintID)
		tempName := g.generateDecodeTempVarName(startBits)

		decodeNormalFieldTempVarDeclData := map[string]any{
			"TyUint":    tyUint,
			"TempName":  tempName,
			"FieldName": g.generateDecodeStructFieldName(field.FieldName),
		}
		declStr := util.ExecuteTemplate(fieldDecoderTemplate, "decodeNormalFieldTempVarDecl", nil, decodeNormalFieldTempVarDeclData)
		decodeStmts = append(decodeStmts, declStr)

		stmts, err := g.generateDecodeNormalFieldImpl(tempName, tempTy, field.FieldOptions, structDynamic, from, to)
		if err != nil {
			return nil, err
		}
		decodeStmts = append(decodeStmts, stmts...)

		decodeNormalFieldTempVarAssignEnumData := map[string]any{
			"FieldName": g.generateDecodeStructFieldName(field.FieldName),
			"EnumDef":   ty,
			"TempName":  tempName,
		}

		assignStr := util.ExecuteTemplate(fieldDecoderTemplate, "decodeNormalFieldTempVarAssignEnum", nil, decodeNormalFieldTempVarAssignEnumData)
		decodeStmts = append(decodeStmts, assignStr)

	case *definition.Array:
		elemTy := ty.ElementType
		elemTySize := (ty.ElementType.GetTypeBitSize() + 7) / 8
		elemBitSize := field.FieldBitSize / ty.Length
		tyUint := typeSizeToUintStr(elemTySize * 8)
		tyUintID := typeSizeMapUint[elemTySize*8]

		name := g.generateDecodeStructFieldName(field.FieldName)

		// temp variable declaration
		var nameIndex func(int64) string
		switch ty.ElementType.(type) {
		case *definition.Struct, *definition.BasicType, *definition.String, *definition.Bytes:
			nameIndex = func(index int64) string {
				return fmt.Sprintf("((%s)[%d])", name, index)
			}
		case *definition.Enum:
			tempName := g.generateDecodeTempVarName(startBits)

			decodeNormalFieldTempVarDeclOnly := map[string]any{
				"TyUint":   tyUint,
				"TempName": tempName,
			}
			declStr := util.ExecuteTemplate(fieldDecoderTemplate, "decodeNormalFieldTempVarDecl", nil, decodeNormalFieldTempVarDeclOnly)
			decodeStmts = append(decodeStmts, declStr)

			nameIndex = func(_ int64) string {
				return tempName
			}

			// change elemTy to temp variable type
			elemTy = definition.GetBasicType(tyUintID)
		default:
			return nil, fmt.Errorf("internal error: unsupported array element type %T", ty.ElementType)
		}

		for i := int64(0); i < ty.Length; i++ {
			subFrom := from + i*elemBitSize
			subTo := from + (i+1)*elemBitSize
			subName := nameIndex(i)

			stmts, err := g.generateDecodeNormalFieldImpl(subName, elemTy, field.FieldOptions, structDynamic, subFrom, subTo)
			if err != nil {
				return nil, err
			}
			decodeStmts = append(decodeStmts, stmts...)

			switch elemTy := ty.ElementType.(type) {
			case *definition.Enum:
				decodeNormalFieldTempVarAssignEnumData := map[string]any{
					"TempName":  subName,
					"EnumDef":   elemTy,
					"FieldName": fmt.Sprintf("((%s)[%d])", name, i),
				}
				assignStr := util.ExecuteTemplate(fieldDecoderTemplate, "decodeNormalFieldTempVarAssignEnum", nil, decodeNormalFieldTempVarAssignEnumData)
				decodeStmts = append(decodeStmts, assignStr)
			default:
			}
		}

	default:
		return nil, fmt.Errorf("internal error: unknown field kind %T", ty)
	}

	return decodeStmts, nil
}

func (g CppGenerator) generateDecodeNormalFieldImpl(fieldNameStr string, fieldType definition.Type, fieldOptions *util.OrderedMap[string, *definition.Option], structDynamic bool, from, to int64) ([]string, error) {
	decodeStmts := []string{}
	fieldBitSize := to - from

	dataDataFunc := func(i int64) string {
		decodeDataData := map[string]any{
			"TyUint8": typeMap[definition.TypeID_Uint8],
			"Dynamic": structDynamic,
			"BytePos": i,
		}
		return util.ExecuteTemplate(fieldDecoderTemplate, "decodeData", nil, decodeDataData)
	}

	switch ty := fieldType.(type) {
	case *definition.Struct:
		decodeNormalFieldStructData := map[string]any{
			"FieldStruct": ty,
			"FieldName":   fieldNameStr,
			"FromByte":    from / 8,
			"Dynamic":     structDynamic,
			"TyUint8":     typeMap[definition.TypeID_Uint8],
			"TyUint64":    typeMap[definition.TypeID_Uint64],
			"TempName":    g.generateDecodeTempVarName(from),
		}

		stmt := util.ExecuteTemplate(fieldDecoderTemplate, "decodeNormalFieldStruct", nil, decodeNormalFieldStructData)
		decodeStmts = append(decodeStmts, stmt)

	case *definition.Enum:
		panic("unreachable, enum field should be handled in generateDecodeNormalField")

	case *definition.String:
		tyString, err := g.GenerateType(&definition.String{})
		if err != nil {
			return nil, err
		}

		decodeNormalFieldStringData := map[string]any{
			"TyUint8":    typeMap[definition.TypeID_Uint8],
			"FieldName":  fieldNameStr,
			"FromByte":   from / 8,
			"TyString":   tyString,
			"MemoryCopy": g.GenCtx.GenOptions.MemoryCopy,
			"TempName":   g.generateDecodeTempVarName(from),
		}

		stmt := util.ExecuteTemplate(fieldDecoderTemplate, "decodeNormalFieldString", nil, decodeNormalFieldStringData)
		decodeStmts = append(decodeStmts, stmt)

	case *definition.Bytes:
		decodeNormalFieldBytesData := map[string]any{
			"TyUint8":    typeMap[definition.TypeID_Uint8],
			"FieldName":  fieldNameStr,
			"FromByte":   from / 8,
			"GetMask":    g.generateHex((1 << 7) - 1),
			"SetMask":    g.generateHex(1 << 7),
			"Shift":      7,
			"MemoryCopy": g.GenCtx.GenOptions.MemoryCopy,
			"TempName":   g.generateDecodeTempVarName(from),
		}

		stmt := util.ExecuteTemplate(fieldDecoderTemplate, "decodeNormalFieldBytes", nil, decodeNormalFieldBytesData)
		decodeStmts = append(decodeStmts, stmt)

	case *definition.BasicType:
		tySize := (ty.GetTypeBitSize() + 7) / 8
		tyUint := typeSizeToUintStr(tySize * 8)
		tyUintID := typeSizeMapUint[tySize*8]

		// cast struct member to proper unsigned type if needed
		templateName := "decodeNormalFieldCast"
		if tyUintID == ty.GetTypeID() {
			templateName = "decodeNormalFieldNoCast"
		}

		// little endian as default
		shiftCalc := func(i int64) string {
			return g.generateDec(i * 8)
		}
		if gen.MatchOption(fieldOptions, "order", "big") {
			// big endian
			shiftCalc = func(i int64) string {
				return g.generateDec(max(0, fieldBitSize-8*(i+1)))
			}
		}

		fieldProcessor := func(expr string, i int64) string {
			// operator is '=' if is filling the first bit, otherwise is '|='
			operator := ""
			if i == 0 {
				operator = exprOpToString[definition.ExprOp_ASSIGN] // "="
			} else {
				operator = exprOpToString[definition.ExprOp_BOR] + exprOpToString[definition.ExprOp_ASSIGN] // "|="
			}

			// exprExp = (tyUint)expr << 8*i or (tyUint)expr << max(0, fieldBitSize-8*(i+1))
			exprExp := &definition.BinopExpr{
				Op: definition.ExprOp_SHL,
				Expr1: &definition.CastExpr{
					ToType: definition.GetBasicType(tyUintID),
					Expr1: &definition.RawExpr{
						Expr: expr,
					},
				},
				Expr2: &definition.RawExpr{
					Expr: shiftCalc(i),
				},
			}

			exprExpStr, err := g.GenerateExpr(exprExp, "")
			if err != nil {
				panic(fmt.Errorf("internal error: %s", err))
			}

			decodeNormalFieldBasicTypeData := map[string]any{
				"TyUint":    tyUint,
				"FieldName": fieldNameStr,
				"Operator":  operator,
				"Expr":      exprExpStr,
			}

			return util.ExecuteTemplate(fieldDecoderTemplate, templateName, nil, decodeNormalFieldBasicTypeData)
		}

		decodeStmts = append(decodeStmts, g.generateDecodeImpl(from, to, fieldProcessor, dataDataFunc)...)

		// extend sign bit
		if ty.GetTypeID().IsInt() && ty.GetTypeBitSize() > fieldBitSize {
			originFromBitSize := fieldBitSize
			extendToBitSize := ty.GetTypeBitSize()
			tyInt := typeSizeToIntStr(tySize * 8)

			switch g.GenCtx.GenOptions.SignExtMethod {
			case gen.SignExtMethodDefault, gen.SignExtMethodShift:
				shift := extendToBitSize - originFromBitSize
				signExtendData := map[string]any{
					"FieldName": fieldNameStr,
					"Shift":     shift,
					"TyInt":     tyInt,
				}

				stmt := util.ExecuteTemplate(fieldDecoderTemplate, "signExtendShift", nil, signExtendData)
				decodeStmts = append(decodeStmts, stmt)

			case gen.SignExtMethodArith:
				signMask := int64(1) << (originFromBitSize - 1)
				signMaskStr := g.generateHex(signMask)
				signExtendData := map[string]any{
					"FieldName": fieldNameStr,
					"SignMask":  signMaskStr,
					"TyInt":     tyInt,
				}

				stmt := util.ExecuteTemplate(fieldDecoderTemplate, "signExtendArith", nil, signExtendData)
				decodeStmts = append(decodeStmts, stmt)

			default:
				panic("unreachable, unknown sign extension method")
			}
		}

	case *definition.Array:
		panic("unreachable, array field should be handled in generateDecodeNormalField")

	default:
		return nil, fmt.Errorf("internal error: unknown field kind %T", ty)
	}

	return decodeStmts, nil
}

// generateDecodeImpl generates decode implementation from 'from' bit to 'to' bit and align to 8 bits
// from: start bit position of encoded data
// to: end bit position of encoded data
// from is inclusive, to is exclusive, i.e. [from, to)
//
// e.g. from = 3, to = 19
//
//	exprOfExtract1stByteFromEncodedData = (((((uint8_t*)data)[0] & 0b11111000) >> 3) | ((((uint8_t*)data)[1] & 0b00000111) << 5))
//	exprOfExtract2ndByteFromEncodedData = (((((uint8_t*)data)[1] & 0b11111000) >> 3) | ((((uint8_t*)data)[2] & 0b00000111) << 5))
//
// fieldData: a function callback to generate expression of decoding x-th byte data (x is the byte index)
//
// e.g. little endian
//
//	fieldProcessor(exprOfExtract1stByteFromEncodedData, 0) -> (*(uint32_t*)(&(structPtr->intField))) = (exprOfExtract1stByteFromEncodedData << 0)
//	fieldProcessor(exprOfExtract2ndByteFromEncodedData, 1) -> (*(uint32_t*)(&(structPtr->intField))) |= (exprOfExtract2ndByteFromEncodedData << 8)
//	fieldProcessor(exprOfExtract3rdByteFromEncodedData, 2) -> (*(uint32_t*)(&(structPtr->intField))) |= (exprOfExtract3rdByteFromEncodedData << 16)
//	fieldProcessor(exprOfExtract4thByteFromEncodedData, 3) -> (*(uint32_t*)(&(structPtr->intField))) |= (exprOfExtract4thByteFromEncodedData << 24)
func (g CppGenerator) generateDecodeImpl(from, to int64, fieldProcessor func(string, int64) string, dataData func(int64) string) []string {
	decodeStmts := []string{}
	// generate decode implentation from 'from' bit to 'to' bit per 8 bits
	// e.g. from = 3, to = 19 -> loop 2 times: 3-10, 11-19 (not aligned to 8 bits!!!)
	for i := from; i < to; i += 8 {

		// we use 'from' and 'to' to denote the bit position in encoded data
		begin := i
		end := min(to, i+8)

		var expr definition.Expr

		// separator to check if is aligned to 8 bits
		sep := min(end, (begin+8)&(^7))
		// first half
		// e.g. begin = 3, end = 10
		//      sep = 8, fieldMask = 0b11111000, shiftRight = 3
		if begin < sep { // always true, just for beauty
			fieldMask := ((1 << (((sep - 1) & 7) + 1)) - 1) & (^((1 << (begin & 7)) - 1))
			shiftRight := begin % 8
			// expr = ((((uint8_t*)data)[begin/8] & fieldMask) >> shiftRight)
			expr = &definition.BinopExpr{
				Op: definition.ExprOp_SHR,
				Expr1: &definition.BinopExpr{
					Op: definition.ExprOp_BAND,
					Expr1: &definition.RawExpr{
						Expr: dataData(begin / 8),
					},
					Expr2: &definition.RawExpr{
						Expr: g.generateBin(fieldMask),
					},
				},
				Expr2: &definition.RawExpr{
					Expr: fmt.Sprintf("%d", shiftRight),
				},
			}
		}
		// second half
		// e.g. begin = 8, end = 10
		//      sep = 8, fieldMask = 0b00000111, shiftLeft = 5
		if sep < end {
			fieldMask := ((1 << (((end - 1) & 7) + 1)) - 1) & (^((1 << (sep & 7)) - 1))
			shiftLeft := 8 - end%8
			// expr = expr | ((((uint8_t*)data)[sep/8] & fieldMask) << shiftLeft)
			expr = &definition.BinopExpr{
				Op:    definition.ExprOp_BOR,
				Expr1: expr,
				Expr2: &definition.BinopExpr{
					Op: definition.ExprOp_SHL,
					Expr1: &definition.BinopExpr{
						Op: definition.ExprOp_BAND,
						Expr1: &definition.RawExpr{
							Expr: dataData(sep / 8),
						},
						Expr2: &definition.RawExpr{
							Expr: g.generateBin(fieldMask),
						},
					},
					Expr2: &definition.RawExpr{
						Expr: fmt.Sprintf("%d", shiftLeft),
					},
				},
			}
		}

		// generate decode expression
		exprStr, err := g.GenerateExpr(expr, "")
		if err != nil {
			panic(fmt.Errorf("internal error: %s", err))
		}

		// generate decode statement
		decodeStmt := fieldProcessor(exprStr, (i-from)/8)
		decodeStmts = append(decodeStmts, decodeStmt)
	}
	return decodeStmts
}

// ==================== GenerateExpr ====================

func (g CppGenerator) GenerateExpr(expr definition.Expr, valueStr string) (string, error) {
	generator := NewCExprGenerator(g.GenerateType, valueStr, g.GenState)
	return g.AcceptExpr(expr, generator)
}

// ==================== Expr Generator ====================

type CExprGenerator struct {
	*gen.GenExprDispatcher
	GenType          func(definition.Type) (string, error)
	ValueStr         string
	GenState         *CppGeneratorState       // optional
	LiteralGenerator gen.LiteralGeneratorImpl // optional
}

func NewCExprGenerator(genType func(definition.Type) (string, error), valueStr string, genState *CppGeneratorState) *CExprGenerator {
	generator := &CExprGenerator{
		GenExprDispatcher: nil,
		GenType:           genType,
		ValueStr:          valueStr,
		GenState:          genState,
	}
	generator.GenExprDispatcher = gen.NewGenExprDispatcher(generator)
	return generator
}

func (g CExprGenerator) GenerateExpr(expr definition.Expr) (string, error) {
	return g.AcceptExpr(expr)
}

var exprOpToString = map[definition.ExprOp]string{
	definition.ExprOp_ADD:    "+",
	definition.ExprOp_SUB:    "-",
	definition.ExprOp_MUL:    "*",
	definition.ExprOp_DIV:    "/",
	definition.ExprOp_MOD:    "%",
	definition.ExprOp_POW:    "**",
	definition.ExprOp_SHL:    "<<",
	definition.ExprOp_SHR:    ">>",
	definition.ExprOp_LT:     "<",
	definition.ExprOp_LE:     "<=",
	definition.ExprOp_GT:     ">",
	definition.ExprOp_GE:     ">=",
	definition.ExprOp_EQ:     "==",
	definition.ExprOp_NE:     "!=",
	definition.ExprOp_BAND:   "&",
	definition.ExprOp_BXOR:   "^",
	definition.ExprOp_BOR:    "|",
	definition.ExprOp_AND:    "&&",
	definition.ExprOp_OR:     "||",
	definition.ExprOp_NOT:    "!",
	definition.ExprOp_BNOT:   "~",
	definition.ExprOp_ASSIGN: "=",
}

func (g CExprGenerator) GenerateUnopExpr(expr *definition.UnopExpr) (string, error) {
	opStr, ok := exprOpToString[expr.Op]
	if !ok {
		return "", fmt.Errorf("unknown unop expr op: %s", expr.Op.String())
	}
	expr1, err := g.GenerateExpr(expr.Expr1)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("(%s%s)", opStr, expr1), nil
}

func (g CExprGenerator) GenerateBinopExpr(expr *definition.BinopExpr) (string, error) {
	switch expr.Op {
	case definition.ExprOp_POW:
		expr1, err := g.GenerateExpr(expr.Expr1)
		if err != nil {
			return "", err
		}
		expr2, err := g.GenerateExpr(expr.Expr2)
		if err != nil {
			return "", err
		}
		if g.GenState != nil {
			g.GenState.UseMathH = true
		}
		return fmt.Sprintf("pow(%s, %s)", expr1, expr2), nil
	default:
		opStr, ok := exprOpToString[expr.Op]
		if !ok {
			return "", fmt.Errorf("unknown binop expr op: %s", expr.Op.String())
		}
		expr1, err := g.GenerateExpr(expr.Expr1)
		if err != nil {
			return "", err
		}
		expr2, err := g.GenerateExpr(expr.Expr2)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("(%s %s %s)", expr1, opStr, expr2), nil
	}
}

func (g CExprGenerator) GenerateCastExpr(expr *definition.CastExpr) (string, error) {
	expr1, err := g.GenerateExpr(expr.Expr1)
	if err != nil {
		return "", err
	}
	ty, err := g.GenType(expr.ToType)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("(%s)%s", ty, expr1), nil
}

func (g CExprGenerator) GenerateConstantExpr(expr *definition.ConstantExpr) (string, error) {
	generator := g.LiteralGenerator
	if generator == nil {
		generator = NewCLiteralGenerator()
	}
	return g.AcceptLiteral(expr.ConstantValue, generator)
}

func (g CExprGenerator) GenerateTenaryExpr(expr *definition.TenaryExpr) (string, error) {
	cond, err := g.GenerateExpr(expr.Cond)
	if err != nil {
		return "", err
	}
	expr1, err := g.GenerateExpr(expr.Expr1)
	if err != nil {
		return "", err
	}
	expr2, err := g.GenerateExpr(expr.Expr2)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("(%s ? %s : %s)", cond, expr1, expr2), nil
}

func (g CExprGenerator) GenerateValueExpr(expr *definition.ValueExpr) (string, error) {
	return g.ValueStr, nil
}

func (g CExprGenerator) GenerateRawExpr(expr *definition.RawExpr) (string, error) {
	return expr.Expr, nil
}

// ==================== Literal Generator ====================

type CLiteralGenerator struct {
	*gen.GenLiteralDispatcher
}

func NewCLiteralGenerator() *CLiteralGenerator {
	generator := &CLiteralGenerator{
		GenLiteralDispatcher: nil,
	}
	generator.GenLiteralDispatcher = gen.NewGenLiteralDispatcher(generator)
	return generator
}

func (g CLiteralGenerator) GenerateLiteral(literal definition.Literal) (string, error) {
	return g.AcceptLiteral(literal)
}

func (g CLiteralGenerator) GenerateBoolLiteral(literal *definition.BoolLiteral) (string, error) {
	return fmt.Sprintf("%t", literal.BoolValue), nil
}

func (g CLiteralGenerator) GenerateIntLiteral(literal *definition.IntLiteral) (string, error) {
	return fmt.Sprintf("%d", literal.IntValue), nil
}

func (g CLiteralGenerator) GenerateFloatLiteral(literal *definition.FloatLiteral) (string, error) {
	return fmt.Sprintf("%f", literal.FloatValue), nil
}

func (g CLiteralGenerator) GenerateStringLiteral(literal *definition.StringLiteral) (string, error) {
	return fmt.Sprintf(`"%s"`, literal.StringValue), nil
}

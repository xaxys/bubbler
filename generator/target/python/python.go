package python

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"text/template"

	"github.com/xaxys/bubbler/definition"
	"github.com/xaxys/bubbler/generator/genctx"
	"github.com/xaxys/bubbler/util"
)

type GeneratedType struct {
	GeneratedDef string
}

type PythonGenerator struct{}

func NewPythonGenerator() *PythonGenerator {
	return &PythonGenerator{}
}

type pyGenCtx struct {
	GenUnit  *definition.CompilationUnit
	GenTypes *util.OrderedMap[string, *GeneratedType]
	GenStack *util.OrderedMap[string, any]
}

var fileTemplate = `
{{- define "file" -}}
# Target: Python
# Generated by bubbler
# DO NOT EDIT

import struct
from enum import Enum
from typing import List

{{ $curUnit := .Unit -}}
{{ range $unit := .Unit.LocalImports.Values -}}
from {{ $unit.Package.ToPath "." "_bb" }} import *
{{ end -}}

{{ range $type := .GenTypes.Values }}
# ==================== CustomType ====================
{{ if $type.GeneratedDef }}
{{ $type.GeneratedDef }}
{{ end }}

{{- end -}}
{{- end -}}
`

func (g *PythonGenerator) Generate(ctx *genctx.GenCtx) error {
	for _, unit := range ctx.Units {
		gen := &pyGenCtx{
			GenUnit:  unit,
			GenTypes: util.NewOrderedMap[string, *GeneratedType](),
			GenStack: util.NewOrderedMap[string, any](),
		}

		for _, type_ := range unit.LocalTypes.Values() {
			gen.generateType(type_)
		}

		if gen.GenTypes.Len() == 0 &&
			unit.Options.Has("omit_empty") &&
			unit.Options.MustGet("omit_empty").OptionValue.GetLiteralValue() == true {
			continue
		}

		data := map[string]any{
			"Unit":     gen.GenUnit,
			"GenTypes": gen.GenTypes,
		}
		str := util.ExecuteTemplate(fileTemplate, "file", nil, data)
		err := ctx.WritePackage(unit.Package, "_bb.py", str)
		if err != nil {
			return err
		}
	}

	return nil
}

var typeMap = map[definition.TypeID]string{
	definition.TypeID_Bool:    "bool",
	definition.TypeID_Uint8:   "int",
	definition.TypeID_Uint16:  "int",
	definition.TypeID_Uint32:  "int",
	definition.TypeID_Uint64:  "int",
	definition.TypeID_Int8:    "int",
	definition.TypeID_Int16:   "int",
	definition.TypeID_Int32:   "int",
	definition.TypeID_Int64:   "int",
	definition.TypeID_Float32: "float",
	definition.TypeID_Float64: "float",
	definition.TypeID_String:  "str",
	definition.TypeID_Bytes:   "str",
}

var typeSizeMapUint = map[int64]definition.TypeID{
	8:  definition.TypeID_Uint8,
	16: definition.TypeID_Uint16,
	32: definition.TypeID_Uint32,
	64: definition.TypeID_Uint64,
}

func (g *pyGenCtx) generateType(type_ definition.Type) (def string) {
	switch val := type_.(type) {
	case *definition.Struct:
		name := val.StructName
		if g.GenTypes.Has(val.StructName) || g.GenStack.Has(val.StructName) {
			return name
		}
		// generate local types only
		if !g.GenUnit.LocalNames.Has(val.StructName) {
			return name
		}
		g.GenStack.Put(val.StructName, nil)
		genTy := g.generateStruct(val)
		g.GenStack.Remove(val.StructName)
		g.GenTypes.Put(val.StructName, genTy)
		return name

	case *definition.Enum:
		name := val.EnumName
		if g.GenTypes.Has(val.EnumName) || g.GenStack.Has(val.EnumName) {
			return name
		}
		// generate local types only
		if !g.GenUnit.LocalNames.Has(val.EnumName) {
			return name
		}
		g.GenStack.Put(val.EnumName, nil)
		genTy := g.generateEnum(val)
		g.GenStack.Remove(val.EnumName)
		g.GenTypes.Put(val.EnumName, genTy)
		return name

	case *definition.BasicType:
		return typeMap[val.TypeTypeID]

	case *definition.Array:
		return fmt.Sprintf("List[%s]", g.generateType(val.ElementType))

	case *definition.String:
		panic("unimplemented")

	case *definition.Bytes:
		panic("unimplemented")

	default:
		panic("unreachable")
	}
}

var typeDefaultValueMap = map[definition.TypeID]string{
	definition.TypeID_Bool:    "False",
	definition.TypeID_Uint8:   "0",
	definition.TypeID_Uint16:  "0",
	definition.TypeID_Uint32:  "0",
	definition.TypeID_Uint64:  "0",
	definition.TypeID_Int8:    "0",
	definition.TypeID_Int16:   "0",
	definition.TypeID_Int32:   "0",
	definition.TypeID_Int64:   "0",
	definition.TypeID_Float32: "0.0",
	definition.TypeID_Float64: "0.0",
	definition.TypeID_String:  `""`,
	definition.TypeID_Bytes:   `""`,
}

func (g *pyGenCtx) generateTypeDefaultValue(type_ definition.Type) (def string) {
	switch val := type_.(type) {
	case *definition.Struct:
		return fmt.Sprintf("%s()", val.StructName)

	case *definition.Enum:
		return fmt.Sprintf("None")

	case *definition.BasicType:
		return typeDefaultValueMap[val.TypeTypeID]

	case *definition.Array:
		return fmt.Sprintf("[%s] * %d", g.generateTypeDefaultValue(val.ElementType), val.Length)

	case *definition.String:
		panic("unimplemented")

	case *definition.Bytes:
		panic("unimplemented")

	default:
		panic("unreachable")
	}
}

var structTemplate = `
{{- define "constantField" -}}
    {{- $pos := .Pos -}}
    {{- $field := .Field -}}
    {{- $fieldName := Tosnake_case .Field.FieldName -}}
    # {{ $pos }} ConstantField: {{ $field.ShortString }}
    {{- if $fieldName -}}
        {{- $tyStr := generateType $field.FieldType }}
        self._{{ $fieldName }}: {{ $tyStr }} = {{ $field.FieldConstant.GetLiteralValue }}
    {{- end -}}
{{- end -}}

{{- define "voidField" -}}
    {{- $pos := .Pos -}}
    {{- $field := .Field -}}
    # {{ $pos }} VoidField: {{ $field.ShortString }}
{{- end -}}

{{- define "embeddedField" -}}
    {{- $pos := .Pos -}}
    {{- $field := .Field -}}
    # {{ $pos }} EmbeddedField: {{ $field.ShortString }}
{{- end -}}

{{- define "normalField" -}}
    {{- $pos := .Pos -}}
    {{- $field := .Field -}}
    {{- $fieldName := Tosnake_case .Field.FieldName -}}
    # {{ $pos }} NormalField: {{ $field.ShortString }}
    {{- $tyStr := generateType $field.FieldType }}
        self._{{ $fieldName }}: {{ $tyStr }} = {{ generateTypeDefaultValue $field.FieldType }}
{{- end -}}

{{- define "field" -}}
    {{- if eq .Field.GetFieldKind .FieldKindID_Constant }}
        {{- template "constantField" . }}
    {{- else if eq .Field.GetFieldKind .FieldKindID_Void }}
        {{- template "voidField" . }}
    {{- else if eq .Field.GetFieldKind .FieldKindID_Embedded }}
        {{- template "embeddedField" . }}
    {{- else if eq .Field.GetFieldKind .FieldKindID_Normal }}
        {{- template "normalField" . }}
    {{- else }}
        {{- panic "unreachable" }}
    {{- end -}}
{{- end -}}

{{- define "structConst" -}}
	@staticmethod
    def size() -> int:
        return {{ .StructSize }}
{{- end -}}

{{- define "structDef" -}}
{{- $structDef := .StructDef -}}
{{- $fieldStrs := .FieldStrs -}}
# Struct: {{ $structDef.ShortString }}
class {{ $structDef.StructName }}:
    def __init__(self):
    {{- range $fieldStr := $fieldStrs }}
        {{ $fieldStr }}
    {{- end }}

    {{ template "structConst" . }}

    {{ .FuncStr }}

{{- end -}}
`

func (g *pyGenCtx) generateStruct(structDef *definition.Struct) *GeneratedType {
	funcMap := template.FuncMap{
		"generateType":             g.generateType,
		"generateTypeDefaultValue": g.generateTypeDefaultValue,
	}

	fields := []string{}
	startBits := int64(0)
	for _, field := range structDef.StructFields {
		from := startBits
		to := startBits + field.GetFieldBitSize()
		startBits += field.GetFieldBitSize()

		pos := fmt.Sprintf("[%s, %s)", util.ToSizeString(from), util.ToSizeString(to))
		if from == to {
			pos = "[virtual]"
		}

		fieldData := map[string]any{
			"Pos":                  pos,
			"Field":                field,
			"FieldKindID_Constant": definition.FieldKindID_Constant,
			"FieldKindID_Void":     definition.FieldKindID_Void,
			"FieldKindID_Embedded": definition.FieldKindID_Embedded,
			"FieldKindID_Normal":   definition.FieldKindID_Normal,
		}

		fieldStr := util.ExecuteTemplate(structTemplate, "field", funcMap, fieldData)
		fields = append(fields, fieldStr)
	}

	funcStr := g.generateStructMethods(structDef)
	funcStr += g.generateEncoder(structDef) + g.generateDecoder(structDef)
	funcStr = util.IndentSpace4NoFirst(funcStr)

	defData := map[string]any{
		"StructDef":  structDef,
		"StructSize": structDef.StructBitSize / 8,
		"FieldStrs":  fields,
		"FuncStr":    funcStr,
	}

	defStr := util.ExecuteTemplate(structTemplate, "structDef", funcMap, defData)

	code := &GeneratedType{
		GeneratedDef: defStr,
	}
	return code
}

var methodsTemplate = `
{{- define "defaultGetter" -}}
{{- $returnType := generateType .ReturnType -}}
{{- $fieldName := Tosnake_case .FieldDef.FieldName -}}
{{- $valueReplacement := printf "self._%s" $fieldName -}}
{{- $expr := generateExpr .Expr $valueReplacement -}}
# DefaultGetter: get_{{ $fieldName }}
def get_{{ $fieldName }}(self) -> {{ $returnType }}:
    return {{ $expr }}

{{ end }}

{{- define "defaultSetter" -}}
{{- $paramType := generateType .ParamType -}}
{{- $fieldName := Tosnake_case .FieldDef.FieldName -}}
{{- $expr := generateExpr .Expr "value" -}}
# DefaultSetter: set_{{ $fieldName }}
def set_{{ $fieldName }}(self, value: {{ $paramType }}) -> None:
    self._{{ $fieldName }} = {{ $expr }}

{{ end }}

{{- define "customGetter" -}}
{{- $returnType := generateType .ReturnType -}}
{{- $fieldName := Tosnake_case .FieldDef.FieldName -}}
{{- $methodName := Tosnake_case .Name -}}
{{- $valueReplacement := printf "self.%s" $fieldName -}}
{{- $expr := generateExpr .Expr $valueReplacement -}}
# CustomGetter: get_{{ $fieldName }}_{{ $methodName }}
def get_{{ $fieldName }}_{{ $methodName }}(self) -> {{ $returnType }}:
    return {{ $expr }}

{{ end }}

{{- define "customSetter" -}}
{{- $paramType := generateType .ParamType -}}
{{- $fieldName := Tosnake_case .FieldDef.FieldName -}}
{{- $methodName := Tosnake_case .Name -}}
{{- $expr := generateExpr .Expr "value" -}}
# CustomSetter: set_{{ $fieldName }}_{{ $methodName }}
def set_{{ $fieldName }}_{{ $methodName }}(self, value: {{ $paramType }}) -> None:
    self._{{ $fieldName }} = {{ $expr }}

{{ end }}

{{- define "rawGetter" -}}
{{- $returnType := generateType .FieldDef.FieldType -}}
{{- $fieldName := Tosnake_case .FieldDef.FieldName -}}
# RawGetter: {{ $fieldName }}
@property
def {{ $fieldName }}(self) -> {{ $returnType }}:
    return self._{{ $fieldName }}

{{ end }}

{{- define "rawSetter" -}}
{{- $paramType := generateType .FieldDef.FieldType -}}
{{- $fieldName := Tosnake_case .FieldDef.FieldName -}}
# RawSetter: {{ $fieldName }}
@{{ $fieldName }}.setter
def {{ $fieldName }}(self, value: {{ $paramType }}) -> None:
    self._{{ $fieldName }} = value

{{ end }}

{{- define "fieldMethods" -}}
{{- $fieldDef := .FieldDef -}}
{{- $methodKindID_Get := .MethodKindID_Get -}}
{{- $methodKindID_Set := .MethodKindID_Set -}}
# FieldMethods: {{ Tosnake_case .FieldDef.FieldName }}
{{ template "rawGetter" (dict "FieldDef" $fieldDef) -}}
{{ template "rawSetter" (dict "FieldDef" $fieldDef) }}
{{- range $method := .FieldDef.FieldMethods }}
    {{- if eq $method.MethodKind $methodKindID_Get }}
        {{- if $method.MethodName }}
            {{- $getterData := dict "FieldDef" $fieldDef "ReturnType" $method.MethodParamType "Expr" $method.MethodExpr "Name" $method.MethodName -}}
            {{- template "customGetter" $getterData }}
        {{- else }}
            {{- $getterData := dict "FieldDef" $fieldDef "ReturnType" $method.MethodParamType "Expr" $method.MethodExpr -}}
            {{- template "defaultGetter" $getterData }}
        {{- end }}
    {{- else if eq $method.MethodKind $methodKindID_Set }}
        {{- if $method.MethodName }}
            {{- $setterData := dict "FieldDef" $fieldDef "ParamType" $method.MethodParamType "Expr" $method.MethodExpr "Name" $method.MethodName -}}
            {{- template "customSetter" $setterData }}
        {{- else }}
            {{- $setterData := dict "FieldDef" $fieldDef "ParamType" $method.MethodParamType "Expr" $method.MethodExpr -}}
            {{- template "defaultSetter" $setterData }}
        {{- end }}
    {{- else }}
        {{- panic "unreachable" }}
    {{- end -}}
{{- end -}}
{{- end -}}

{{- define "structMethods" -}}
{{- $fieldKindID_Constant := .FieldKindID_Constant -}}
{{- $fieldKindID_Void := .FieldKindID_Void -}}
{{- $fieldKindID_Embedded := .FieldKindID_Embedded -}}
{{- $fieldKindID_Normal := .FieldKindID_Normal -}}
{{- $methodKindID_Get := .MethodKindID_Get -}}
{{- $methodKindID_Set := .MethodKindID_Set -}}
{{- range $field := .StructDef.StructFields }}
    {{- if eq $field.GetFieldKind $fieldKindID_Normal }}
        {{- template "fieldMethods" dict "FieldDef" $field "MethodKindID_Get" $methodKindID_Get "MethodKindID_Set" $methodKindID_Set }}
    {{- end -}}
{{- end -}}
{{- end -}}
`

func (g *pyGenCtx) generateStructMethods(structDef *definition.Struct) string {
	funcMap := template.FuncMap{
		"generateExpr": g.generateExpr,
		"generateType": g.generateType,
	}

	data := map[string]interface{}{
		"StructDef":            structDef,
		"FieldKindID_Constant": definition.FieldKindID_Constant,
		"FieldKindID_Void":     definition.FieldKindID_Void,
		"FieldKindID_Embedded": definition.FieldKindID_Embedded,
		"FieldKindID_Normal":   definition.FieldKindID_Normal,
		"MethodKindID_Get":     definition.MethodKindID_Get,
		"MethodKindID_Set":     definition.MethodKindID_Set,
	}

	methodsStr := util.ExecuteTemplate(methodsTemplate, "structMethods", funcMap, data)
	return methodsStr
}

var exprTemplate = `
{{- define "notExpr" -}}
	(not {{generateExpr .Expr.Expr1 .ValueReplacement}})
{{- end -}}

{{- define "andExpr" -}}
	({{generateExpr .Expr.Expr1 .ValueReplacement}} and {{generateExpr .Expr.Expr2 .ValueReplacement}})
{{- end -}}

{{- define "orExpr" -}}
	({{generateExpr .Expr.Expr1 .ValueReplacement}} or {{generateExpr .Expr.Expr2 .ValueReplacement}})
{{- end -}}

{{- define "unopExpr" -}}
    ({{.Expr.Op}}{{generateExpr .Expr.Expr1 .ValueReplacement}})
{{- end -}}

{{- define "binopExpr" -}}
    ({{generateExpr .Expr.Expr1 .ValueReplacement}} {{.Expr.Op}} {{generateExpr .Expr.Expr2 .ValueReplacement}})
{{- end -}}

{{- define "castExpr" -}}
    ({{generateType .Expr.ToType}})({{generateExpr .Expr.Expr1 .ValueReplacement}})
{{- end -}}

{{- define "tenaryExpr" -}}
    {{generateExpr .Expr.Expr1 .ValueReplacement}} if {{generateExpr .Expr.Cond .ValueReplacement}} else {{generateExpr .Expr.Expr2 .ValueReplacement}}
{{- end -}}

{{- define "constantExpr" -}}
    {{- if .Expr.ConstantValue.GetLiteralKind.IsBool -}}
		{{- if .Expr.ConstantValue.GetLiteralValue -}}
			True
		{{- else -}}
			False
		{{- end -}}
	{{- else -}}
		{{ .Expr.ConstantValue }}
	{{- end -}}
{{- end -}}

{{- define "valueExpr" -}}
    {{.ValueReplacement}}
{{- end -}}

{{- define "expr" -}}
    {{- if eq .Expr.GetExprKind .ExprKindID_UnopExpr -}}
        {{- if eq .Expr.Op .ExprOp_NOT -}}
			{{- template "notExpr" . -}}
		{{- else -}}
			{{- template "unopExpr" . -}}
		{{- end -}}
    {{- else if eq .Expr.GetExprKind .ExprKindID_BinopExpr -}}
		{{- if eq .Expr.Op .ExprOp_AND -}}
			{{- template "andExpr" . -}}
		{{- else if eq .Expr.Op .ExprOp_OR -}}
			{{- template "orExpr" . -}}
		{{- else -}}
        	{{- template "binopExpr" . -}}
		{{- end -}}
    {{- else if eq .Expr.GetExprKind .ExprKindID_CastExpr -}}
        {{- template "castExpr" . -}}
    {{- else if eq .Expr.GetExprKind .ExprKindID_TenaryExpr -}}
        {{- template "tenaryExpr" . -}}
    {{- else if eq .Expr.GetExprKind .ExprKindID_ConstantExpr -}}
        {{- template "constantExpr" . -}}
    {{- else if eq .Expr.GetExprKind .ExprKindID_ValueExpr -}}
        {{- template "valueExpr" . -}}
    {{- else -}}
        {{- panic .Expr -}}
    {{- end -}}
{{- end -}}
`

func (g *pyGenCtx) generateExpr(expr definition.Expr, valueReplacement string) string {
	funcMap := template.FuncMap{
		"generateExpr": g.generateExpr,
		"generateType": g.generateType,
	}

	data := map[string]interface{}{
		"Expr":                    expr,
		"ValueReplacement":        valueReplacement,
		"ExprKindID_UnopExpr":     definition.ExprKindID_UnopExpr,
		"ExprKindID_BinopExpr":    definition.ExprKindID_BinopExpr,
		"ExprKindID_CastExpr":     definition.ExprKindID_CastExpr,
		"ExprKindID_TenaryExpr":   definition.ExprKindID_TenaryExpr,
		"ExprKindID_ConstantExpr": definition.ExprKindID_ConstantExpr,
		"ExprKindID_ValueExpr":    definition.ExprKindID_ValueExpr,
		"ExprOp_ADD":              definition.ExprOp_ADD,
		"ExprOp_SUB":              definition.ExprOp_SUB,
		"ExprOp_MUL":              definition.ExprOp_MUL,
		"ExprOp_DIV":              definition.ExprOp_DIV,
		"ExprOp_MOD":              definition.ExprOp_MOD,
		"ExprOp_POW":              definition.ExprOp_POW,
		"ExprOp_SHL":              definition.ExprOp_SHL,
		"ExprOp_SHR":              definition.ExprOp_SHR,
		"ExprOp_LT":               definition.ExprOp_LT,
		"ExprOp_LE":               definition.ExprOp_LE,
		"ExprOp_GT":               definition.ExprOp_GT,
		"ExprOp_GE":               definition.ExprOp_GE,
		"ExprOp_EQ":               definition.ExprOp_EQ,
		"ExprOp_NE":               definition.ExprOp_NE,
		"ExprOp_BAND":             definition.ExprOp_BAND,
		"ExprOp_BXOR":             definition.ExprOp_BXOR,
		"ExprOp_BOR":              definition.ExprOp_BOR,
		"ExprOp_AND":              definition.ExprOp_AND,
		"ExprOp_OR":               definition.ExprOp_OR,
		"ExprOp_NOT":              definition.ExprOp_NOT,
		"ExprOp_BNOT":             definition.ExprOp_BNOT,
	}

	exprStr := util.ExecuteTemplate(exprTemplate, "expr", funcMap, data)
	return exprStr
}

var enumTemplate = `
{{- define "enumDef" -}}
# Enum: {{ .ShortString }}
class {{ .EnumName }}(Enum):
{{- range .EnumValues.Values }}
    {{ .EnumValueName }} = {{ .EnumValue }}
{{- end }}

{{- end -}}
`

func (g *pyGenCtx) generateEnum(enumDef *definition.Enum) *GeneratedType {
	enumDefStr := util.ExecuteTemplate(enumTemplate, "enumDef", nil, enumDef)

	code := &GeneratedType{
		GeneratedDef: enumDefStr,
	}

	return code
}

//
// ==================== Encoder & Decoder ====================
// TODO: Templateify the encoder & decoder
//

func getStructPackID(tyID definition.TypeID) string {
	idMap := map[definition.TypeID]string{
		definition.TypeID_Bool:    "B",
		definition.TypeID_Uint8:   "B",
		definition.TypeID_Uint16:  "H",
		definition.TypeID_Uint32:  "I",
		definition.TypeID_Uint64:  "Q",
		definition.TypeID_Int8:    "b",
		definition.TypeID_Int16:   "h",
		definition.TypeID_Int32:   "i",
		definition.TypeID_Int64:   "q",
		definition.TypeID_Float32: "f",
		definition.TypeID_Float64: "d",
	}
	return idMap[tyID]
}

func (g *pyGenCtx) generateEncoder(structDef *definition.Struct) string {
	genEncode := func(from, to int64, fieldData func(int64) string) string {
		encodeStr := ""
		for i := from; i < to; i = (i + 8) & (^7) {
			nextI := min(to, (i+8)&(^7))
			dataMask := ((1 << (((nextI - 1) & 7) + 1)) - 1) & (^((1 << (i & 7)) - 1))
			operator := "="
			if i%8 != 0 {
				operator = "|="
			}

			begin := i - from
			end := nextI - from
			fieldStr := ""

			j := begin
			if j < end {
				nextJ := min(end, (j+8)&(^7))
				fieldMask := ((1 << (((nextJ - 1) & 7) + 1)) - 1) & (^((1 << (j & 7)) - 1))
				shiftRight := j % 8
				fieldStr += fmt.Sprintf("(((%s) & 0b%b) >> %d)", fieldData(j/8), fieldMask, shiftRight)
				j = nextJ
			}
			if j < end {
				nextJ := min(end, (j+8)&(^7))
				fieldMask := ((1 << (((nextJ - 1) & 7) + 1)) - 1) & (^((1 << (j & 7)) - 1))
				shiftLeft := 8 - nextJ%8
				fieldStr += fmt.Sprintf(" | (((%s) & 0b%b) << %d)", fieldData(j/8), fieldMask, shiftLeft)
				j = nextJ
			}

			shiftLeft := i % 8
			encodeStr += fmt.Sprintf("data[%d] %s (((%s) << %d) & 0b%b)\n", i/8, operator, fieldStr, shiftLeft, dataMask)
		}
		return encodeStr
	}

	str := fmt.Sprintf("# Encoder: %s\n", structDef.StructName)
	str += fmt.Sprintf("def encode(self) -> str:\n")
	encodeStr := fmt.Sprintf("data = bytearray(%d)\n", structDef.StructBitSize/8)
	startBits := int64(0)
	for fieldIndex, field := range structDef.StructFields {
		from := startBits
		to := startBits + field.GetFieldBitSize()
		startBits += field.GetFieldBitSize()
		pos := fmt.Sprintf("[%s, %s)", util.ToSizeString(from), util.ToSizeString(to))

		switch val := field.(type) {
		case *definition.ConstantField:
			encodeStr += fmt.Sprintf("# %s %s\n", pos, val.ShortString())

			var byteOrder binary.ByteOrder = binary.LittleEndian
			if option, ok := val.FieldOptions.Get("order"); ok {
				if option.OptionValue.GetLiteralValue() == "big" {
					byteOrder = binary.BigEndian
				}
			}

			buffer := &bytes.Buffer{}
			value := val.FieldConstant.GetLiteralValueIn(val.FieldType)
			err := binary.Write(buffer, byteOrder, value)
			if err != nil {
				panic(fmt.Errorf("internal error: %s", err))
			}
			data := buffer.Bytes()

			fieldData := func(i int64) string {
				return fmt.Sprintf("0x%X", data[i])
			}
			encodeStr += genEncode(from, to, fieldData)

		case *definition.VoidField:
			encodeStr += fmt.Sprintf("# %s %s\n", pos, val.ShortString())
			encodeStr += genEncode(from, to, func(i int64) string { return "0" })

		case *definition.EmbeddedField:
			continue

		case *definition.NormalField:
			encodeStr += fmt.Sprintf("# %s %s\n", pos, val.ShortString())
			name := fmt.Sprintf("self._%s", val.FieldName)

			switch ty := val.FieldType.(type) {
			case *definition.Struct:
				encodeStr += fmt.Sprintf("data[%d:%d] = %s.encode()\n", from/8, to/8, name)

			case *definition.Enum:
				fieldBitSize := val.FieldBitSize
				tempName := fmt.Sprintf("temp_field_%d", fieldIndex)
				encodeStr += fmt.Sprintf("%s = %s.value\n", tempName, name)

				var fieldData func(int64) string
				// 默认编码为小端序
				if option, ok := val.FieldOptions.Get("order"); ok {
					if option.OptionValue.GetLiteralValue() == "big" {
						// 大端序
						fieldData = func(i int64) string {
							return fmt.Sprintf("(%s >> %d)", tempName, max(fieldBitSize-i*8-8, 0))
						}
					}
				}
				if fieldData == nil {
					// 小端序
					fieldData = func(i int64) string {
						return fmt.Sprintf("(%s >> %d)", tempName, i*8)
					}
				}
				encodeStr += genEncode(from, to, fieldData)

			case *definition.BasicType:
				fieldBitSize := val.FieldBitSize
				var fieldData func(int64) string
				// 默认编码为小端序
				if option, ok := val.FieldOptions.Get("order"); ok {
					if option.OptionValue.GetLiteralValue() == "big" {
						// 大端序
						if ty.TypeTypeID.IsFloat() {
							id := getStructPackID(ty.TypeTypeID)
							uid := getStructPackID(typeSizeMapUint[ty.TypeBitSize])
							fieldData = func(i int64) string {
								return fmt.Sprintf("(struct.unpack('<%s', struct.pack('<%s', %s))[0] >> %d)", uid, id, name, max(fieldBitSize-i*8-8, 0))
							}
						} else {
							fieldData = func(i int64) string {
								return fmt.Sprintf("(%s >> %d)", name, max(fieldBitSize-i*8-8, 0))
							}
						}
					}
				}
				if fieldData == nil {
					// 小端序
					if ty.TypeTypeID.IsFloat() {
						id := getStructPackID(ty.TypeTypeID)
						uid := getStructPackID(typeSizeMapUint[ty.TypeBitSize])
						fieldData = func(i int64) string {
							return fmt.Sprintf("(struct.unpack('<%s', struct.pack('<%s', %s))[0] >> %d)", uid, id, name, i*8)
						}
					} else {
						fieldData = func(i int64) string {
							return fmt.Sprintf("(%s >> %d)", name, i*8)
						}
					}
				}
				encodeStr += genEncode(from, to, fieldData)

			case *definition.Array:
				elemBitSize := val.FieldBitSize / ty.Length

				var nameIndex func(int64) string
				switch ty.ElementType.(type) {
				case *definition.BasicType:
					nameIndex = func(index int64) string {
						return fmt.Sprintf("%s[%d]", name, index)
					}
				case *definition.Enum:
					tempName := fmt.Sprintf("temp_field_%d", fieldIndex)
					nameIndex = func(index int64) string {
						return tempName
					}
				default:
					panic("unreachable")
				}

				var fieldDataIndex func(int64) func(int64) string
				// 默认编码为小端序
				if option, ok := val.FieldOptions.Get("order"); ok {
					if option.OptionValue.GetLiteralValue() == "big" {
						// 大端序
						fieldDataIndex = func(index int64) func(int64) string {
							return func(i int64) string {
								name := nameIndex(index)
								return fmt.Sprintf("(%s >> %d)", name, max(elemBitSize-i*8-8, 0))
							}
						}
					}
				}
				if fieldDataIndex == nil {
					// 小端序
					fieldDataIndex = func(index int64) func(int64) string {
						return func(i int64) string {
							name := nameIndex(index)
							return fmt.Sprintf("(%s >> %d)", name, i*8)
						}
					}
				}
				for i := int64(0); i < ty.Length; i++ {
					subFrom := from + i*elemBitSize
					subTo := from + (i+1)*elemBitSize
					fieldData := fieldDataIndex(i)
					if _, ok := ty.ElementType.(*definition.Enum); ok {
						encodeStr += fmt.Sprintf("%s = %s[%d].value\n", nameIndex(i), name, i)
					}
					encodeStr += genEncode(subFrom, subTo, fieldData)
				}

			default:
				fieldData := func(i int64) string {
					return fmt.Sprintf("%s[%d]", name, i)
				}
				encodeStr += genEncode(from, to, fieldData)
			}
		default:
			panic("unreachable")
		}
	}
	encodeStr += "return data\n"
	encodeStr = util.IndentSpace4(encodeStr)
	str += encodeStr
	str += fmt.Sprintf("\n")
	return str
}

func (g *pyGenCtx) generateDecoder(structDef *definition.Struct) string {
	genDecode := func(from, to int64, fieldProcessor func(string, int64) string) string {
		decodeStr := ""
		for i := int64(0); i < to-from; i += 8 {
			nextI := min(to-from, (i+8)&(^7))
			// dataMask := ((1 << (((nextI - 1) & 7) + 1)) - 1) & (^((1 << (i & 7)) - 1))

			begin := from + i
			end := from + nextI
			fieldStr := ""

			j := begin
			if j < end {
				nextJ := min(end, (j+8)&(^7))
				fieldMask := ((1 << (((nextJ - 1) & 7) + 1)) - 1) & (^((1 << (j & 7)) - 1))
				shiftLeft := j % 8
				fieldStr += fmt.Sprintf("((data[%d] & 0b%b) >> %d)", j/8, fieldMask, shiftLeft)
				j = nextJ
			}
			if j < end {
				nextJ := min(end, (j+8)&(^7))
				fieldMask := ((1 << (((nextJ - 1) & 7) + 1)) - 1) & (^((1 << (j & 7)) - 1))
				shiftRight := 8 - nextJ%8
				fieldStr += fmt.Sprintf(" | ((data[%d] & 0b%b) << %d)", j/8, fieldMask, shiftRight)
				j = nextJ
			}

			decodeStr += fmt.Sprintf("%s\n", fieldProcessor(fieldStr, i/8))
		}
		return decodeStr
	}

	// signExtend := func(from, to int64, fieldStr string) string {
	//     if from >= to {
	//         return fieldStr
	//     }
	//     return fmt.Sprintf("((int%d_t)((%s) << %d) >> %d)", to, fieldStr, to-from, to-from)
	// }

	// another sign extend implementation
	signExtend2 := func(from, to int64, fieldStr string) string {
		signMask := uint64(1) << (from - 1)
		return fmt.Sprintf("((%s ^ 0x%X) - 0x%X)", fieldStr, signMask, signMask)
	}

	str := fmt.Sprintf("# Decoder: %s\n", structDef.StructName)
	str += fmt.Sprintf("def decode(self, data: str) -> bool:\n")
	decodeStr := ""
	startBits := int64(0)
	for fieldIndex, field := range structDef.StructFields {
		from := startBits
		to := startBits + field.GetFieldBitSize()
		startBits += field.GetFieldBitSize()
		pos := fmt.Sprintf("[%s, %s)", util.ToSizeString(from), util.ToSizeString(to))

		switch val := field.(type) {

		case *definition.ConstantField:
			decodeStr += fmt.Sprintf("# %s %s\n", pos, val.ShortString())

			name := fmt.Sprintf("self._%s", val.FieldName)
			if val.FieldName == "" {
				tyStr := g.generateType(val.FieldType)
				name = fmt.Sprintf("temp_field_%d", fieldIndex)
				decodeStr += fmt.Sprintf("%s %s\n", tyStr, name)
			}

			fieldBitSize := val.FieldBitSize
			var fieldProcessor func(string, int64) string

			// 默认解码为小端序
			if option, ok := val.FieldOptions.Get("order"); ok {
				if option.OptionValue.GetLiteralValue() == "big" {
					// 大端序
					fieldProcessor = func(fieldStr string, i int64) string {
						operator := "="
						if i != 0 {
							operator = "|="
						}
						return fmt.Sprintf("%s %s ((%s) << %d)", name, operator, fieldStr, max(fieldBitSize-i*8-8, 0))
					}
				}
			}

			if fieldProcessor == nil {
				// 小端序
				fieldProcessor = func(fieldStr string, i int64) string {
					operator := "="
					if i != 0 {
						operator = "|="
					}
					return fmt.Sprintf("%s %s ((%s) << %d)", name, operator, fieldStr, i*8)
				}
			}

			decodeStr += genDecode(from, to, fieldProcessor)

			if val.FieldType.TypeTypeID.IsInt() {
				decodeStr += fmt.Sprintf("%s = %s\n", name, signExtend2(val.FieldBitSize, val.FieldType.TypeBitSize, name))
			}
			if val.FieldType.TypeTypeID.IsFloat() {
				decodeStr += fmt.Sprintf("%s = struct.unpack('<%s', struct.pack('<%s', %s))[0]\n", name, getStructPackID(val.FieldType.TypeTypeID), getStructPackID(typeSizeMapUint[val.FieldType.TypeBitSize]), name)
			}

			decodeStr += fmt.Sprintf("if %s != %s:\n    return False\n", name, val.FieldConstant)

		case *definition.VoidField:
			decodeStr += fmt.Sprintf("# %s %s\n", pos, val.ShortString())
			continue

		case *definition.EmbeddedField:
			continue

		case *definition.NormalField:
			decodeStr += fmt.Sprintf("# %s %s\n", pos, val.ShortString())
			name := fmt.Sprintf("self._%s", val.FieldName)

			switch ty := val.FieldType.(type) {
			case *definition.Struct:
				decodeStr += fmt.Sprintf("if not %s.decode(data[%d:]):\n    return False\n", name, from/8)

			case *definition.Enum:
				fieldBitSize := val.FieldBitSize
				tempName := fmt.Sprintf("temp_field_%d", fieldIndex)

				var fieldProcessor func(string, int64) string
				// 默认解码为小端序
				if option, ok := val.FieldOptions.Get("order"); ok {
					if option.OptionValue.GetLiteralValue() == "big" {
						// 大端序
						fieldProcessor = func(fieldStr string, i int64) string {
							operator := "="
							if i != 0 {
								operator = "|="
							}
							return fmt.Sprintf("%s %s ((%s) << %d)", tempName, operator, fieldStr, max(fieldBitSize-i*8-8, 0))
						}
					}
				}
				if fieldProcessor == nil {
					// 小端序
					fieldProcessor = func(fieldStr string, i int64) string {
						operator := "="
						if i != 0 {
							operator = "|="
						}
						return fmt.Sprintf("%s %s ((%s) << %d)", tempName, operator, fieldStr, i*8)
					}
				}
				decodeStr += genDecode(from, to, fieldProcessor)
				decodeStr += fmt.Sprintf("%s = %s(%s)\n", name, ty.EnumName, tempName)

				// TODO: sign extend of enum. DO THIS AFTER SUPPORTING NEGATIVE ENUM VALUES
				// if basicTy, ok := ty.(*definition.BasicType); ok {
				//     if basicTy.TypeTypeID.IsInt() && basicTy.TypeBitSize > val.FieldBitSize {
				//         decodeStr += fmt.Sprintf("%s = %s\n", name, signExtend(val.FieldBitSize, basicTy.TypeBitSize, name))
				//     }
				// }

			case *definition.BasicType:
				fieldBitSize := val.FieldBitSize
				var fieldProcessor func(string, int64) string
				// 默认解码为小端序
				if option, ok := val.FieldOptions.Get("order"); ok {
					if option.OptionValue.GetLiteralValue() == "big" {
						// 大端序
						fieldProcessor = func(fieldStr string, i int64) string {
							operator := "="
							if i != 0 {
								operator = "|="
							}
							return fmt.Sprintf("%s %s ((%s) << %d)", name, operator, fieldStr, max(fieldBitSize-i*8-8, 0))
						}
					}
				}
				if fieldProcessor == nil {
					// 小端序
					fieldProcessor = func(fieldStr string, i int64) string {
						operator := "="
						if i != 0 {
							operator = "|="
						}
						return fmt.Sprintf("%s %s ((%s) << %d)", name, operator, fieldStr, i*8)
					}
				}
				decodeStr += genDecode(from, to, fieldProcessor)

				if ty.TypeTypeID.IsInt() {
					decodeStr += fmt.Sprintf("%s = %s\n", name, signExtend2(val.FieldBitSize, ty.TypeBitSize, name))
				}
				if ty.TypeTypeID.IsFloat() {
					decodeStr += fmt.Sprintf("%s = struct.unpack('<%s', struct.pack('<%s', %s))[0]\n", name, getStructPackID(ty.TypeTypeID), getStructPackID(typeSizeMapUint[ty.TypeBitSize]), name)
				}

			case *definition.Array:
				elemBitSize := val.FieldBitSize / ty.Length
				var nameIndex func(int64) string
				switch ty.ElementType.(type) {
				case *definition.BasicType:
					nameIndex = func(index int64) string {
						return fmt.Sprintf("%s[%d]", name, index)
					}
				case *definition.Enum:
					tempName := fmt.Sprintf("temp_field_%d", fieldIndex)
					nameIndex = func(index int64) string {
						return tempName
					}
				default:
					panic("unreachable")
				}
				var fieldProcessorIndex func(int64) func(string, int64) string
				// 默认解码为小端序
				if option, ok := val.FieldOptions.Get("order"); ok {
					if option.OptionValue.GetLiteralValue() == "big" {
						// 大端序
						fieldProcessorIndex = func(index int64) func(string, int64) string {
							return func(fieldStr string, i int64) string {
								operator := "="
								if i != 0 {
									operator = "|="
								}
								name := nameIndex(index)
								return fmt.Sprintf("%s %s ((%s) << %d)", name, operator, fieldStr, max(elemBitSize-i*8-8, 0))
							}
						}
					}
				}
				if fieldProcessorIndex == nil {
					// 小端序
					fieldProcessorIndex = func(index int64) func(string, int64) string {
						return func(fieldStr string, i int64) string {
							operator := "="
							if i != 0 {
								operator = "|="
							}
							name := nameIndex(index)
							return fmt.Sprintf("%s %s ((%s) << %d)", name, operator, fieldStr, i*8)
						}
					}
				}
				for i := int64(0); i < ty.Length; i++ {
					subFrom := from + i*elemBitSize
					subTo := from + (i+1)*elemBitSize
					fieldProcessor := fieldProcessorIndex(i)
					decodeStr += genDecode(subFrom, subTo, fieldProcessor)
					if enumTy, ok := ty.ElementType.(*definition.Enum); ok {
						decodeStr += fmt.Sprintf("%s[%d] = %s(%s)\n", name, i, enumTy.EnumName, nameIndex(i))
					}
				}

				if basicTy, ok := ty.ElementType.(*definition.BasicType); ok {
					if basicTy.TypeTypeID.IsInt() {
						for i := int64(0); i < ty.Length; i++ {
							elemName := fmt.Sprintf("%s[%d]", name, i)
							decodeStr += fmt.Sprintf("%s = %s\n", elemName, signExtend2(elemBitSize, basicTy.TypeBitSize, elemName))
						}
					}
					if basicTy.TypeTypeID.IsFloat() {
						for i := int64(0); i < ty.Length; i++ {
							elemName := fmt.Sprintf("%s[%d]", name, i)
							decodeStr += fmt.Sprintf("%s = struct.unpack('<%s', struct.pack('<%s', %s))[0]\n", elemName, getStructPackID(basicTy.TypeTypeID), getStructPackID(typeSizeMapUint[basicTy.TypeBitSize]), elemName)
						}
					}
				}

			default:
				fieldProcessor := func(fieldStr string, i int64) string {
					operator := "="
					return fmt.Sprintf("(%s[%d] %s %s", val.FieldName, i, operator, fieldStr)
				}
				decodeStr += genDecode(from, to, fieldProcessor)
			}

		default:
			panic("unreachable")
		}
	}
	decodeStr += "return True\n"
	decodeStr = util.IndentSpace4(decodeStr)
	str += decodeStr
	str += "\n"
	return str
}
